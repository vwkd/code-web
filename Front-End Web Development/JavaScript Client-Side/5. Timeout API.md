# Timeout APIs

[TOC]

## `setTimeout()`

`WindowOrWorkerGlobalScope.setTimeout(callback, delay)`

- executes callback after a delay of delay ms, simple timer
- returns unique identifier, integer, same pool of IDs as `setInterval()`

- if timer has not yet elapsed can cancel using `clearTimeout(timeoutID)` (or `clearInterval(timeoutID)`)

  beware: an invalid ID does not throw an error ❗️

- `this` in callback will be back to default (global object / undefined in non / strict mode) since callback is passed as argument to another function, can preserve it by wrapping _value of callback_ in anonymous function❗️

  ```javascript
  setTimeout(() => {callback()}, delay)
  ```

- nested `setTimeout` calls are throttled by browser, in foreground maximal every 4 ms, in background maximal every 1s
- the delay is actually only the minimum wait time, because the task queue needs to wait until the call stack is clear before the callback can be executed (see Runtime)

- for animation use `requestAnimationFrame()`



## `setInterval()`

`WindowOrWorkerGlobalScope.setInterval(callback, delay)`

- executes callback every delay ms, simple timer
- returns unique identifier, integer, same pool of IDs as `setTimeout()`

- if timer has not yet elapsed can cancel using `clearInterval(timeoutID)` (or `clearTimeout(timeoutID)`)

  beware: an invalid ID does not throw an error ❗️

- `this` in callback will be back to default (global object / undefined in non / strict mode) since callback is passed as argument to another function, can preserve it by wrapping _value of callback_ in anonymous function❗️

  ```javascript
  setInterval(() => {callback()}, delay)
  ```

- nested `setInterval` calls are throttled by browser, in foreground maximal every 4 ms, in background maximal every 1s
- the delay is actually only the minimum wait time, because the task queue needs to wait until the call stack is clear before the callback can be executed (see Runtime)
- interval does not adjust to how long code takes to run, i.e. if code runs longer than delay, next call is run even before previous returned
- use setInterval to guarantee constant delay between consecutive call starts, while recursive setTimeout to guarantee constant delay between previous call finish and next call start



## `requestAnimationFrame()`

- adapts frame rate to screen refresh rate, pauses if page not visible, etc.
- if needs custom running rate use `setTimeout

<!-- ToDo: write content -->