# Introduction

[TOC]

<!-- ToDo: Clean up --> 

## TypeScript

- statically typed superset of JS that compiles to plain JS
- write JS as usual, add types
- (also works as a transpiler for older ES versions, but better use only for types and use Babel for transpilation)
- types allow for powerful error checking, e.g. control flow, function arguments, available methods, etc.
- error check layer is just during development, type declaration get deleted on compilation to JS
- security is gone as soon as compiled to JS, e.g. `readonly` properties, `private` class members ⚠️
- type checking makes sense anyways only during development, on client can not do anything
- TS doesn't prevent compilation if there is a type related error, since is still valid JS
- implements new JS features when reach Stage 3
- zero cost: no performance overhead since it all "compiles away", as if you had written JS in the first place, but without bugs ;)
- static type-checking
- give variables, functions, etc. strict types, restrict values, enable more reasoning about behavior
- types are narrowed down based on control flow, type guards, assignments, etc.
- goes backwards and makes dynamically typed JS to statically typed TS, but implicit inference hides a lot of typing
- but statically typed means engine can run it faster because of optimisations
- TS has very powerful types, whole programming language around types, can combine conditionally, everything is a type
- takes just JS type system and writes it down so can reason about during development, static formalisation of JS's dynamic type system
- enforces the subset of JS that makes sense, not the one that is syntactically valid
- TS doesn't inject anything in the code, compiles to plain JS
- adds static types
- powerful tooling with error checking right when writing code, not only later when trying to run it, no need to implement unit tests for every line of code
- can use types to build documentation, no need to annotate just for documentation, avoids extra layer of complexity and potential errors
- any professional JavaScript development needs TypeScript, otherwise would need to write unit tests for every single line of code, can not sleep at night
- nobody forces you to strongly type everything, no binary choice between yes and no, can dial it up gradually, the more types the more checking
- primary purpose of types is to enable tooling during development, e.g. error checking, statement completion, safe refactoring, code navigation etc.
- elevated development experience
- can again sleep well at night
- statement completion in context, only the semantically valid, not like other IDEs any function
- technically it's own language, but follows exactly ECMAScript specs, like JavaScript with type annotations, no overhead in translating JS implementation into TS implementation
- without type information would need to know everything by heart or look it up, with type information the IDE can describe and error check input
- type checker knows values have different functionality, e.g. a `toString()` method but not necessarily a `toUpperCase()` method

- dynamically typed language: values hold types, not variables
- statically typed language: variables hold type in addition to values
TS turns dynamically typed JS in statically typed
TypeScript: A Static Type Checker

- exact same runtime behavior and syntax, no translation, only layer on top

## Implicit typing

- types get inferred where ever possible, e.g. in variable assignment, return type of function, etc.
- don't need to provide types for everything, but safer so can not later accidentally change them and use them for documentation

```typescript
const age = 42;

age.toUpperCase(); // error since age is number and not string
```

- the declared type determines the types that are allowed to be assigned, even if in meantime had a more specific type

```typescript
let x = Math.random() < 0.5 ? 42 : "world";
    
x = 1;            
x = "goodbye!";
// both valid assignments since declared type was string | number
```

## Structural typing

- type compatibility is checked using duck typing ("If it walks like a duck and quacks like a duck, it is a duck!")
- one type is compatible with another, as long as it implements _at least_ all properties of the other type

```typescript
interface Named {
  name: string;
}

function sayHi(obj: Named) {
  console.log(`Hi, my name is ${obj.name}.`);
}

const p = { name: "Peter", age: 42 };
sayHi(p); // Hi, my name is Peter.
```

```typescript
interface Named {
  name: string;
}

class Person {
  name: string;
  age: number;
}

const q: Named = new Person();
```

- allows to extend existing types ???

## Control Flow Analysis

- TS narrows down types to more specific types when it can
- in if statements, switch statements, loops, conditional ternaries, etc.
- using type guards in condition, e.g. `typeof`, `instanceof`, equality operator, truthiness

## Resources

- [The New TypeScript Handbook](https://github.com/microsoft/TypeScript-New-Handbook)
- [Anders Hejlsberg - What's new in TypeScript](https://channel9.msdn.com/Events/Speakers/Anders-Hejlsberg)
- [TSConf 2018](https://www.youtube.com/playlist?list=PL2z7rCjEG2ksF0rJ8Qwp1y5eTjqiPIRfT), [TSConf 2019](https://www.youtube.com/playlist?list=PL2z7rCjEG2kumYQw0tl-afLYWUk-kKREB)