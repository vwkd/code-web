# Types

[TOC]

## Introduction

- types are sets of values, set theory
- can assign type to variables, function parameters, function return type, object properties, etc.
- type gets fixed once set, otherwise typing wouldn't make any sense since it couldn't be used to reason about code
- using colon after name, like in classical languages

```typescript
const age1: number = 42;

function sayAge(age: number): string {
    return `Hello, I am ${age} years old.`;
}

console.log(sayAge(age1));
```

- implicit typing: types get inferred where ever possible, e.g. in variable assignment, return type of function, etc.

```typescript
const age = 42;

age.toUpperCase(); // error since age is number and not string
```

- optional operator: append `?` after variable or property, makes variable optional and possibly `undefined`


## Basic Types

| types | description |
| ----- | ----------- |
| `boolean` | boolean values (* and `null` and `undefined`) |
| `number` | number values (* and `null` and `undefined`) |
| `string` | string values (* and `null` and `undefined`) |
| `bigint` | bigint values (* and `null` and `undefined`) |
| `symbol` | symbol values (* and `null` and `undefined`) |
| `object` | object values (* and `null` and `undefined`) |
| `undefined` | `undefined` (* and `null`) |
| `null` | `null` (* and `undefined`) |
| `any` | any value, no type checking |
| `never`| non-existent value, subtype of every other type, e.g. if function throws error or never returns due to infinite loop |
| `void` | no value, subtype of `undefined` (* and `null`) |
| `<type>[]` | array of `<type>`, variable length |
| `[<type>, ..., <type>]` | tuple of different types, known length |
| `{key1: <type>, ..., keyN: <type>}` | object type, known length |

- by default `null` and `undefined` are subtypes of every other type, e.g. can assign `undefined` to `number`, disable using `strictNullChecks` flag (disables *)
- always use lowercase types, uppercase are special built-in ???
- can also use constructor names instead, e.g. `Array<type>`, but not often used ???

## Object types

```typescript
const o : { a: string, b: number } = {a: "foo", b: 12};
```

- type of object properties
- uses object literal syntax
- types need to be written after object or array destructuring

```typescript
// object
const o = {a: "foo", b: 12, c: "bar"};
const { a, b }: { a: string, b: number } = o;

// tuple
const [name, age]: [string, number] = ["Peter", 42];
```

- can make object properties readonly by adding `readonly` before property name, effectively like const for object properties

```typescript
const o : { readonly a: string, b: number } = {a: "foo", b: 12};

o.b = 14;
o.a = "bar"; // TS2540: Cannot assign to 'a' because it is a read-only property.
```

## Union types

- combine existing types to form new ones
- values may be any one of those types
- for a union type only the intersection of all the types' properties are available, e.g. `slice()` for type `<type>[] | string` but not `toUpperCase()`

```typescript
function greet(id: number | string) {
  console.log("Hello, agent " + id);
}

greet(007);
greet("Bond");
```

## Type aliases

```typescript
type ID = number | string;

type Person = {
  firstName: string,
  lastName: string,
  age: number
};
```

- alias for a type
- can be reused instead of typing out literal type
- alias names must be unique
- aliases don't create new types, are just names for existing ones ❗️

```typescript
type s1 = string;
type s2 = string;

const p1: s1 = "Hello";
const p2: s2 = p1; // legal, since s1, s2 are aliasing the identical type string
```

## Interfaces

```typescript
interface Person {
  firstName: string,
  lastName: string,
  age: number
}
```

- alias for an _object_ type
- interfaces may be extended, type aliases not ???
- interfaces may participate in declaration merging, type aliases not ???
- structural typing: types are compatible if they have the same members, interfaces can be distinct, just the assigned type must have at least the properties of the specified one

```typescript
interface Named {
  name: string;
}

class Person {
  name: string;
  age: number;
}

const p: Named = new Person();
```

- recursive types are cut off at level 5 ???

## Literal types

```typescript
const x: "Hello World!" = "Hello World!";

function sayDirection(dir: 'up' | 'left' | 'down' | 'right'): void {
    console.log(`Please go ${dir}.`)
}
sayDirection('up');
```

- values of type boolean, string, number can themselves be used as types
- often useful to restrict input to certain values
- literal types are not infered, instead more general type, i.e. `const x = 42` is inferred to be a `number` not a `42`
- general type may conflict with literal type even though values match, then needs to use type assertion to narrow type down type to literal type

```typescript
function sayDirection(dir: 'up' | 'left' | 'down' | 'right'): void {
    console.log(`Please go ${dir}.`)
}

const myobj = {mydir: 'up'}; // mydir is of type 'string', not of type 'up'

sayDirection(myobj.mydir); // TS2345: Argument of type 'string' is not assignable to parameter of type '"up" | "left" | "down" | "right"'.

sayDirection(myobj.mydir as 'up'); // specify myobj.mydir as type 'up'

const myobj2 = {mydir: 'up' as 'up'}; // mydir is of type 'up'

sayDirection(myobj2.mydir);
```

## Type assertion

- can specify more specific type by post-pending `as <type>` when compiler chooses type to broadly, e.g. when selecting DOM nodes
- also less specific ???
- non-null assertion operator: append `!` after variable, makes type assertion that value isn't `null` or `undefined`, use cautiously

```typescript
const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;
```
