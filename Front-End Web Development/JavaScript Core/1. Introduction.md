# Introduction

<!-- ToDo: find all "see ..." and link to corresponding location -->

[TOC]



## JavaScript

- just-in-time compiled object oriented scripting language
- dynamic typing, prototype-based inheritance, first-class functions
- client-side JS runs in browser, uses Web APIs  
  control behavior of Web pages, neither structure nor appearance
- server-side JS runs in runtime environment, e.g. Node.js  
  control server
- standard language is called ECMAScript (ES), "JavaScript" is trademark of Oracle, has no relation with Java except historic name to attract popularity
- file extension .js

### JavaScript versions

| ES (ECMAScript) | year      |
| --------------- | --------- |
| ES1             | 1997      |
| ES2             | 1998      |
| ES3             | 1999      |
| ES4             | abandoned |
| ES5             | 2009      |
| ES6 / ES2015    | 2015      |
| ES7 / ES2016    | 2016      |
| ES2017          | 2017      |
| ES[year+]       | [year+]   |



## Syntax

- case sensitive
- uses Unicode charset, e.g. Umlaute are allowed
- semicolon after each statement, not mandatory since interpreter infers missing ones from line break, but leaving out may lead to unexpected errors line break was unintended
- whitespace is ignored, only for readability, space, tab, newline, comments get converted to whitespace on interpretation
- single-line comments `//`, multi-line comments `/*...*/`
- statements get interpreted in order of appearance



## Identifier

- sequence of characters to identify variable, function, property, etc.
- can contain letters, digits, \_, \$, can not start with digit, convention is to not use \_ or \$ as they are used by external modules
- cannot be keyword, e.g. `true`, `var`, `function`, `if`, `return`, etc.
- convention is to use lower camelCase for variables functions, properties, and upper CamelCase for constructors and classes
- case sensitive



## Variables

- named reference of storage address in memory
- can be declared and initialised

### Declaration

- single: `keyword identifier;`
- multiple: `keyword identifier1, identifier2;`
- non-initialised variables are automatically initialised to `undefined` ‚ùóÔ∏è

### Initialisation

- single: `identifier = value;`
- multiple: `identifier1 = identifier2 = value;`

### Declaration and initialisation

- single: `keyword identifier = value;`
- multiple: `keyword identifier1, identifier2 = value;`

### Variable types

#### `var` üëé

- only function scope
- if not initialised is automatically initialised to `undefined`
- can be accessed before declaration with value `undefined`
- in global scope becomes property of global object, one of the bad quirks of JS ‚ùóÔ∏è

#### `let` üëç

- function and block scope
- if not initialised is automatically initialised to `undefined`
- can not be accessed until declaration, temporary death zone

#### `const` üëç

- function and block scope
- must be initialised when declared, cannot be reassigned  
  (since pointer stays the same array and object content can still be changed)

### Scope

- see Scope in Functions

### Hoisting

- before code is executed, variable declarations and function declarations are processed first into a memory "dictionary" for the containing scope, e.g. all variables inside a function declaration
- practically looks as if declarations were moved to top of containing scope, "hoisted"
- declaration is hoisted, but not initialisation ‚ùóÔ∏è
- declaration is hoisted even if it would never be executed, e.g. because it's inside a non-true if statement, etc. ‚ùóÔ∏è
- var is hoisted and initialised with `undefined`, as if it was declared with `var identifier` on top of containing scope

```javascript
// normal declaration, automatic initialisation of undefined
var x;
console.log(x); // undefined

// as if "var x;" was hoisted to top, has value undefined
x = 3;
console.log(x); // 3
var x;

// as if "var x;" was hoisted to top, has value undefined
console.log(x); // undefined
var x;

// as if "var x;" was hoisted to top, has value undefined
console.log(x); // undefined
var x = 3;

// confirmation that var variables are really hoisted
// if x wouldn't be hoisted it would log "42", but it "knows" of later declaration, because it is hoisted to top of function scope
var x = 42;
(function() {
  console.log(x); // undefined
  var x = 21;
}());
```

- function declarations are hoisted in entirety with body, as as if it was declared on top of containing scope
- function declarations rule over variable declarations, but not variable initialisations
- for multiple function declarations with the same name, the latter overwrites the former, no matter if it will be executed or not, e.g. after return statement, etc.

```javascript
// as if "function y() {...};" was hoisted to top
y(); // "Hello World!"
function y() {console.log("Hello World!");};

// as if "var y;" was hoisted to top, has value undefined
y(); // TypeError: y is not a function
var y = function() {console.log("Hello World!");};

// function declaration rules over variable declaration but not variable initialisation
function y() {}
var y;
alert(typeof y); // "function"
var y = 42;
alert(typeof y); // "number"

// as if "function y() {...};" was hoisted to top
y(); // "Hello World!"
var y = 42;
function y() {console.log("Hello World!");};

// as if "function y() {...};" was hoisted to top of containing function, later definition overrode earlier, doesn't matter if code never reaches it
function x() {
  function y() {
      return 42;
  }
  return y();
  function y() {
      return 21;
  }
}
console.log(x()); // 21
```

- let, const and classes are also hoisted to top of containing scope, but not initialised, remain without a value until the declaration (instead of `undefined`), "Temporal Death Zone", i.e. can't be read or assigned before declaration ‚ùóÔ∏è

```javascript
// normal declaration, automatic initialisation of undefined
let x;
console.log(x); // undefined

// x exists but has no value, can't read or assign
x = 3; // ReferenceError: Cannot access 'x' before initialization
console.log(x);
let x;

// x exists but has no value, can't read or assign
console.log(x); // ReferenceError: Cannot access 'x' before initialization
let x;

// x exists but has no value, can't read or assign
console.log(x); // ReferenceError: Cannot access 'x' before initialization
let x = 3;

// confirmation that let variables are really hoisted
// if x wouldn't be hoisted it would log "42", but it "knows" of later declaration, because it is hoisted to top of function scope
let x = 42;
(function() {
  console.log(x); // ReferenceError: Cannot access 'x' before initialization
  let x = 21;
}());
```

- some challenges

```javascript
var x = 42;
(function() {
  if (!x) {
    var x = 21;
  }
  console.log(x); // 21
}())
// because x is hoisted to top of function with value undefined, the if statement executes

var x = 42;
(function() {
  x = 10;
  return;
  function x() {}
}())
console.log(x); // 42
// because x is hoisted as function declaration to top of function, it creates a separate local x that is assigned 10, so the outer x is not changed

if (!window.x) {
  var x = 42;
}
console.log(a); // undefined
// as if "var x;" was hoisted to top, has value undefined, because window.x does exists, the if statement is not run
```

### Destructuring assignment

- unpack values from arrays and object properties into distinct variables (with ES6)
- can use in variable assignment or as function parameters in function definition

```javascript
// basic array destructuring
const [a, b] = [1, 2, 3, 4, 5];
console.log(a); // 1
console.log(b); // 2

// using default values
const [a = 21, b = 42] = [1];
console.log(a); // 1
console.log(b); // 42
```

- array destructuring can be used to swap variables, e.g. `[a, b] = [b, a]`
- variable names must be the same name as the property names of the object ‚ùóÔ∏è
- if object doesn't have own property, it's prototype chain is looked up ‚ùóÔ∏è

```javascript
// basic object destructuring
const {a, b} = {a: 1, b: 2, c: 3};
console.log(a); // 1
console.log(b); // 2

// new variable names
const {a: x, b: y} = {a: 1, b: 2, c: 3};
console.log(x); // 1
console.log(y); // 2

// default values
const {a = 21, b = 42} = {a: 1};
console.log(a); // 1
console.log(b); // 42

// new variable names and default values
const {a: x = 21, b: y = 42} = {a: 1};
console.log(x); // 1
console.log(y); // 42
```

- if variables already exists need to wrap in parentheses in object destructuring to not be interpreted as block

```javascript
let a, b;
[a, b] = [1, 2, 3, 4, 5];
console.log(a); // 1
console.log(b); // 2

let a, b;
({a, b} = {a: 1, b: 2, c: 3});
console.log(a); // 1
console.log(b); // 2
```

- see rest syntax how to unpack variable number of values



## Data types

- set of similar data
- defines its possible values and operations, e.g. a boolean can only have the two values `true` and `false`

### Primitive data types

- fundamental data types
- data is immutable, can not be changed  
  beware: don't confuse data with variable, variable can be changed, but data itself like `"Hello"` can not be changed
- JS has 7 primitive data types
  - Boolean: true and false
  - Number: integer or floating point number
  - BigInt: integer with arbitrary precision
  - String: sequence of characters, text
  - Symbol: unique identifiers
  - null: empty value
  - undefined: missing value

### Composite data types

- data type made up of primitive data types
- data is mutable, can be changed, e.g. item of array
- JS has 1 composite data type
  - Object: container for data
- all primitive data types except null and undefined have associated object types, e.g. `String` for strings, the `valueOf()` method of those objects returns the primitive value (see later Objects)

### Conversion

- JS is dynamically typed, no need to specify data type of variable, can assign other as well
- coercion: JS automatically converts data types to expected data type whereever needed, might have unexpected outcomes

<!-- ToDo: expand -->

### Literals

- notation to represent fixed value in source code "literally", e.g. `45`, `"Hello"`, `[1, 2, 3]`
- often says data type to refer to literal of said data type, e.g. `"Hello"` is a string (literal)

#### Boolean literals

`true` and `false`

#### Number literals

##### Integer literals

- decimal: $d_i \ldots d_0$ with $d_i \in \{0,1,\ldots,9\}$, e.g. `117`, no leading zero
- hexadecimal: prefix `0x` or `0X`, e.g. `0x1123`
- octal: prefix `0o` or `0O`, e.g. `0o77`
- binary: prefix `0b` or `0B`, e.g. `0b11`

##### Floating-point literals

- decimal: $+$/$-d_i \ldots d_0.d_i \ldots d_0E$/$e+$/$-d_i \ldots d_0$, e.g. `-4.20e6`, no leading zero

#### BigInt literals

- same as integer literals, just with suffix `n`, e.g. `117n`

#### String literal

- any character(s) enclosed in quotes, single or double, but of same type, e.g. `"Hello World!"`
- template literal: back-ticks instead of quotes, e.g. `&grave;Hello World!&grave;`, can run over multiple lines and do string interpolation using `${expression}`, e.g. `${myStr.includes('cool') ? 'hay' : 'nay'}` (with ES6)
- needs to escape special characters with backslash, e.g. `\n`, `\\` or `\"`
- UTF-16 code unit `\uXXXX` for hex digits `X`  
  UTF-32 code unit `\u{X...X}` for hex digits `X`

#### Array literals

`[item1, item2, item3]`

- empty places get interpreted as undefined
- the last trailing comma is ignored if the place before was empty

#### Object literal

`{key1: value1, key2: value2}`

- key must be valid identifier or enclosed in quotes



## Conditional statements

### if...else statement

```javascript
if (condition) {
  statement1;
} else {
  statement2;
}
```

- can add `else if` statement(s) in middle, only first true condition will be executed, can also omit `else`
- any data type in Boolean context is converted to Boolean
- falsy values: values that are converted to false  
  `false`, `undefined`, `null`, `0`, `NaN`, `""`
- truthy values: values that are converted to true  
  everything else, i.e. especially `true`, `1`, `" "`, `"0"`, `[]`, `{}`, `function() {}`, _any_ object, etc.
- condition can be any expression because of truthy / falsy evaluation
- can run if statement with condition that variable is non-empty, e.g. `if (variable) {...}`

### switch statement

```javascript
switch (expression) {
  case match1:
    statement1;
  case match2:
    statement2;
  default:
    statement;
}
```

- expression gets compared strictly to cases, i.e. uses `===`
- any matching case gets executed on after the other
- stop switch with `break` keyword in each case
- if `break` is forgotten, will run all following cases until next `break` regardless if criterion was met, "falling through" ‚ö†Ô∏è
- `default` is executed if no match is found, doesn't need to be last case, if no `break` begins to fall through into any following cases ‚ö†Ô∏è

### try...catch statement

```javascript
try {
  statement1;
} catch (exception) {
  statement2;
}
```

- try block contains the statement to execute
- catch block contains the statement to execute as soon as try throws an exception, if no exception is skipped
- catch block is passed the exception as argument



## Loops

### labeled statement

```javascript
label: {statement;};
```

- label must be valid identifier
- used to reference outer loop, such that can break out / continue from within nested loop

### break statement

```javascript
break;
break label;
```

- terminates / "breaks out of" inner most enclosing statement
- using label terminates the whole labeled statement

### continue statement

```javascript
continue;
continue break;
```

- skips inner most enclosing statement to next iteration
- using label skips the whole labeled statement

### for statement

```javascript
for (initialExpression; condition; incrementExpression) {
  statement;
}
```

- condition is tested before each loop
- increment expression is executed at end of each loop

### while statement

```javascript
while (condition) {
  statement;
}
```

- like for loop, except:
- initial expression is defined outside beforehand
- increment expression is part of statement

### do...while statement

```javascript
do {
  statement;
} while (condition);
```

- like while loop, except:
- condition is checked after each loop, i.e. runs at least once

### for...in statement

```javascript
for (const property in object) {
  statement;
}
```

- loops over all enumerable property _names_ of an object
- includes inherited enumerable properties ‚ùóÔ∏è
- doesn't necessarily iterate in order, implementation dependent
- use only for debugging to see all properties

### for...of statement

```javascript
for (const value of object) {
  statement;
}
```

- loops over all property _values_ of an iterable object
- object must define properties in its `@@iterable` method‚ùì
- e.g. for array is simply all indices



## Operators

### Assignment operators

`=`, `+=`, `-=`, `*=`, `/=`, `%=`, `**=`, (`<<=`, `>>=`, `>>>=`, `&=`, `^=`, `|=`)

- can use destructuring to unpack data from objects and arrays, e.g. `let [a, b, c] = [1, "Hi", function() {...}]`
- an assignment expression returns the operand, e.g. in `a = b = 5` the expression `b = 5` returns `b`

```javascript
const obj = {};

// usual
obj["world"] = 42;
obj[42] = "world";

// using return value of assignment
obj[obj["world"] = 42] = "world";
```

### Comparison operators

`==`, `!=`, `===`, `!==`, `>`, `<`, `>=`, `<=`

- all comparison operators except `===` and `!==` use automatic type conversion if operans are not of the same type
- beware: due to various historical bad parts, `==` operator is _not_ transitive ‚ö†Ô∏è

```javascript
0 == ""           // true
0 == "0"          // true
"" == "0"         // false

false == "false"  // false
false == "0"      // true
" \n\r\s " == 0   // true
```

<!-- ToDo: expand from DJF -->

### Arithmetic operators

`+`, `-`, `*`, `/`, `%`, `**`, `**`, `--`, `+`, `-`

- only for numeric data types, i.e. Number, BigInt
- divide by zero produces `Infinity` object
- decrement operators: prefix, returns value after subtracting / adding `1`  
  increment operators: postfix, returns value before subtracting / adding `1`

### Bitwise operators

`&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`

### Logical operators

`&&`, `||`, `!`, `??` (ES2020)

- converts values according to truthy and falsy
- short-circuit evaluation is used
- `&&` returns leftmost falsy operand, last one if all truthy
- `||` returns leftmost truthy operand, last one if all falsy
- i.e. `&&` and `||` return one of the compared values, not a boolean ‚ùóÔ∏è
- use `&&` to check for null objects, e.g. `let name = obj && obj.name` is `obj.name` if `obj` exists, else `null` since it's set to `obj ` which is null, or replace if...statement upon returning
- use `||` to fill in default values, e.g. `let name = user || "stranger"`, or replace if...statement upon returning
- prepend value with `!!` as shorthand to convert to boolean
- precedence: `!` > comparison operators > `||` > `&&`

### String operators

`+`, `+=`

- any value will be converted to string first, e.g. `console.log(4 + 5 + "6") // "456"`

### Conditional / ternary operator

`condition ? val1 : val2`

- if condition is truthy, returns `val1`, if falsy returns `val2`
- i.e. returned value is not the condition ‚ùóÔ∏è, e.g.

```javascript
// parentheses around ternary operator just for ease of understanding, not needed
let result = (expression ? value1 : value2);        // doesn't assign expression!
let status = (age >= 18 ? "adult" : "minor");       // doesn't assign age!
() => {return (username ? "Welcome" : "No entry")}; // doesn't return username!
```

- often used to replace simple if...else statement, e.g. when checking for non-emptiness of variable
- don't use ternary operator if expression is used as one value as well, use simpler `&&` instead, e.g. when checking for null objects
- can chain to create more complex conditions

```typescript
function compare(x, y): -1 | 0 | 1 {
  return x === y ? 0 : x > y ? 1 : -1;
}
```

### delete operator

`delete identifier`

- deletes own property from an object
- returns false if property is non-configurable, else true  
  beware: returns true even if property doesn't exist ‚ùóÔ∏è
- doesn't actually free any memory, this is done by garbage collection automatically
- deleted property can still "exist" if an identically named property is inherited
- doesn't correct `length` property of an array, use `Array.prototype.splice()` method instead
- doesn't work for prebuilt things, only self-defined things

### typeof operator

`typeof (expression)`

- returns type as string "object", "function", "number", "string", "boolean", "undefined", i.e. when using in condition doesn't need strict equality since only returns string ‚ùóÔ∏è
- beware: arrays and null are confusingly both "object", use `Array.isArray()` and `=== null` for null ‚ö†Ô∏è

### void operator

`void (expression)`

- evaluates expression without returning a value, i.e. returns undefined
- can be used in links, e.g. `<a href="javascript: void(document.form.submit())">...</a>`

### in operator

`property in object`

- returns true if property is in object / index is in array

### instanceof operator

`object instanceof constructor`

- tests if object inherits from given object type, i.e. if constructor is ancestor
- checks if constructor's `prototype` property appears in the object's prototype chain, i.e. `object.[[prototype]].....[[prototype]] == constructor.prototype` for one or more `[[prototype]]`s "chained"

### ellipsis operator

`...`

#### spread syntax

- expands iterable into multiple elements, e.g. as arguments in function call or items in array literal, iterable can be array, string, etc.
- expands object's own enumerable properties in object literal (with ES2020)
- i.e. no need to use `Function.prototype.apply()` anymore to pass array as arguments to function, no need to use `Array.prototype.concat()` anymore to concat arrays, etc.

```javascript
function sum(a, b, c) {
  return a + b + c;
}
const numbers = [1, 2, 3];
console.log(sum(...numbers)); // 6

const a = [3, 4];
const b = [1, 2, ...a, 5];

const a = {x: 1, y: 2};
const b = {...a, z: 3};
```

#### rest syntax

- condenses arbitrary number of arguments into array in parameter of function definition or destructuring assignment
- condenses arbitrary number of object own enumerable properites into object in object destructuring assignment (with ES2020)
- rest parameter must always be last parameter

```javascript
function sum(...args) {
  return args.reduce((accumulator, currentValue) => accumulator + currentValue);
}

console.log(sum(1, 2, 3));     // 6

let [a, ...b] = [1, 2, 3];
console.log(b);               // [2, 3]

let {x, ...b} = {x: 1, y: 2, z: 3};
console.log(x);               // 1
console.log(b);               // {y: 2, z: 3}
```

- spread syntax is opposite of rest syntax, former destructures arrays and objects into elements and properties, latter condenses elements and properties into arrays and objects, former is in argument of function call, latter in argument of function definition
- use rest and spread syntax to hand through arguments to a function

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;  
  }
}

function newPerson(...args) {
  return new Person(...args);
}

const p = newPerson("Peter", 42);
```

### Other operators

- `()`: grouping operator, controls precedence of expression evaluation
- `.`, `[]`: property accessors, access properties of object
- `new` operator, etc.



## Resources

- MDN - [JavaScript Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide)
- Wikipedia for terminology
- Douglas Crockford
- Ben Cherry - [JavaScript Scoping and Hoisting](http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html)
- Fabr√≠cio S. Matt√© - [Temporal Dead Zone (TDZ) demystified](http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified)
