# Objects

[TOC]

## Motivation

- every data type in JS is either an object, e.g. arrays, functions, objects, or behaves like an object, e.g. strings, numbers, booleans

  -> needs to understand objects to understand JS

- inheritance is the distinct feature of objects in comparison to other data types

  -> can build powerful data structures



## Introduction

- collection of key-value pairs, called "properties", properties are like variables, object is like a container for multiple variables

- property names can be of data type `String` or `Symbol`

- property values can be of any data type including object, function, array, etc.

  -> can build nested data structures of arbitrary complexity

- properties are called methods if the property value is a function

- objects are only mutable data type, properties can be modified after creation, reference stays the same, i.e. `const a = {}` and `a.name = "Peter"` is valid

- objects are addressed / passed ❓"by reference", not "by value" like primitive data types, i.e. if `a` is an object and `let b = a`, then `b` refers to the same identical object as `a`, not only a copy

- objects are compared "by reference", not "by value" like primitive data types, i.e. `let a = {}`, `let b = {}`, then `a === b` is false, because `a` and `b` are not referencing to the same object



## Object literals

### Creating object literals

```javascript
/*const car1 =*/ {make:	"Honda",														// property
  							  model:	"Civic",													// property
             			year:	1998,																// property
            		  honk: function() {console.log("Hooonk");},// method
          		    beep() {console.log("Beeep");},						// method, shorthand with ES5
         			    blub : alreadyExistingFunction						// method
         			    }
```

- comma seperated key-value pairs, like in arrays

- if key is not valid identifier, must be enclosed in quotes, e.g. `{"1number": 42}`

- can use reserved keyword as key, since ES5 without quotes, (except internally used keyword `__proto__`)

- can use computed property values, i.e. variables as values

  ```javascript
  const value1 = "Honda";
  const car1 = {make: value1,
                model: "Civic",
                year: 1998};
  ```

- can use computed property names, i.e. variables as keys, since ES6

  ```javascript
  const key1 = "make";
  const car1 = {[key1]: "Honda",
                model: "Civic",
                year: 1998};
  ```

- property value shorthand if property names should be the same as the variable name

  ```javascript
  const make = "Honda";
  const model = "Civic";
  const year = 1998;
  const car1 = {make,
                model,
                year};
  ```

- object properties are locally scoped in object, not accessible from outside, (except if object is global object)

- computed property names get converted to string if they aren't already, (uses `Object.prototype.toString()` method)

- property names must be unique, or the last will overwrite the previous, in strict mode will throw error

- can use spread operator to copy own enumerable properties from other object, see ellipsis operator

### Accessing and changing properties

- dot notation: `car1.make`, `car1.honk()`

- can only use if key is valid identifier and not computed property name, else must use bracket notation

- bracket notation: `car1[make]`, `car1[honk]()`

- can use with variable or any string in quotes as key, e.g. `obj["1number"]`

- return `undefined` if property doesn't exist

- can chain if value itself is object

- set property values by assignment, doesn't matter what variable type the object reference is, e.g. `const`

  ```javascript
  car1.year = 1999;
  car1.honk = function() {console.log("Move b****, get out da way!")};
  ```

- if sets property that doesn't exists a new property is created in this object

  -> very powerful, can add and remove properties on the fly

- delete operator to delete own property, see delete operator

### Getters and Setters

```javascript
const car1 = {...
              owners: ["Bob", "Sarah", "James"],								// owners, first to current
              set currentOwner(name) {owners += name;},
              get currentOwner() {return owners[owners.length - 1];}
             }
console.log(car1.currentOwner); // "James"
car1.currentOwner = "Zoe";			// Zoe just bought the car
console.log(car1.currentOwner); // "Zoe"
```

- bind object's property to a function call

- behaves like any other property, can be accesses, set, or deleted, but is itself not a property, e.g. there is no property `currentOwner` in above example, it's just getters and setters

- can make property seem like it stores dynamically computed value

  beware: using getters and setters one can't trust anymore that an object's properties stay the same if they haven't been modified, since now they can be modified internally through different "properties", use cautiously❗️

- set: takes exactly one argument, no return statement

- get: takes exactly zero arguments, has return statement

- can not have a normal property with the same name as get / set

- use `Object.defineProperty()` to define getters and setters for existing object



## Constructors

- regular function, but designed to be called with `new` keyword
- convention is to name with upper CamelCase

### Terminology

- object type: abtract notion of type of object, e.g. cars, trucks, bikes
- constructor: blueprint for object type, e.g. `Car` constructor creates car objects
- instance: object created using a particular constructor, e.g. `car1` is instance of `Car`

### `this` keyword

- `this` refers to an object, like a variable

- which object depends on the context, often source of confusion

- outside of any function in global context `this` is the global object

- in a function generally `this` is the global object in non-strict mode or `undefined` in strict mode

  - in a method, `this` is the object the method is called on, doesn't matter where function was defined, outside, on prototype chain, etc.❗️

    ```javascript
    car1.sayHi = function() {console.log("Hi, my make is " + this.make);};
    car1.sayHi(); // "Hi, my make is Honda"
    ```

  - in a constructor, i.e. called by `new` operator, `this` refers to the object being constructed

  - in an event handler, `this` is the object the event handler is attached to, is not necessarily the same object the event targeted, see Events

- beware: `this` depends only on how function was called, not how it was defined, e.g. if a method is passed as value and then called independent from object, it's `this` will be back to default ⚠️

  ```javascript
  // invoked as function
  function sayHi() {console.log("Hi, my make is " + this.make);};
  sayHi(); // "Hi, my make is undefined"
  
  // invoked as method
  car1.sayHi = sayHi;
  car1.sayHi(); // "Hi, my make is Honda"
  
  // invoked as function
  const func = car1.sayHi
  func(); // "Hi, my make is undefined"
  
  // invoked as function
  function execute(callback) {
    callback();
  }
  execute(car1.sayHi); // "Hi, my make is undefined"
  
  // "undefined" since "this" is global object in non-strict mode which has no property "make"
  ```

- use `Function.prototype.call`/`apply()` to call any function with `this` being specified, or create entirely new function using `Function.prototype.bind()` with `this` being fixed

  ```javascript
  func.call(car1); // "Hi, my make is Honda"
  func.apply(car1); // "Hi, my make is Honda"
  func(); // "Hi, my make is undefined"
  
  const func2 = car1.sayHi.bind(car1);
  func2();  // "Hi, my make is Honda"
  ```

### `new` operator

- operates on a function, but used specifically with constructor or class

  `new Constructor()`

- usually assigns it to a variable

- steps of the `new` operator:

  1. creates a new empty object
  2. sets its `[[prototype]]` property to the constructor's `prototype` property (see later)
  3. calls the constructor with `this` being the new object
  4. returns `this` (if the function doesn't return it's own object)

### Constructor function

```javascript
function Car(make, model, year) {
  this.make = make;													// property
  this.model = model;												// property
  this.year = year;													// property
  this.honk = function() {console.log("Hooonk");};// method
  this.beep = function() {console.log("Beeep");};	// method, no shorthand
  this.blub = alreadyExistingFunction;						// method
}

/*const car1 =*/ new Constructor("Honda", "Civic", 1998)
```

- constructor is simply a function that sets object properties of object in `this`, as if setting any other object's properties, just object has weird name "this"

- when called via `new` operator, it exactly sets all the properties for the newly created object

- constructor has no return statement, otherwise calling it with `new` doesn't make sense, the newly created object would not be used (see step 4. in steps of the `new` operator), wouldn't be a constructor

- use dot notation, because the property names are _not_ computed, i.e. only the assigned `make` becomes the argument variables value, not the `make` in `this.make`

- object created with constructor is identical to object literal equivalent, except when using constructor also inheritance is set up (see later)

  -> use constructor if wants to create many objects that inherit, object literal if only needs single generic

- syntax is different from object literal, semicolons instead of commas, equal signs instead of colons

- beware: forgetting `new` operator when calling constructor, makes it modify properties of global object in non-strict mode ⚠️ one reason to always use strict mode



## Inheritance

### Idea

- let object types inherit from each other, e.g. `SportsCar` from `Car` from `Vehicle`

- only define what's different, inherit what's the same, i.e. not one huge constructor for all types of objects and neighter one full constructor for every single type of object

  -> better scalability, maintainability, readability, etc.

### Inheritance model

- JS uses a prototype-based inheritance model, as opposed to the traditional class-based inheritance model, single mainstream programming language to date that does this
- objects themselves are "prototypes" from which other objects can inherit, instead of classes
- constructors are like traditional classes and the `new` operator like traditional constructors

- JS offers more flexibility than traditional class-based OOP, can freely add / remove properties to individual objects without having to modify whole class, allows to modify prototype objects at run-time to change inherited properties, allows to change whole inheritance chain at run-time

- JS does not support multiple inheritance, i.e. every object inherits only from exactly one other object

### The `[[prototype]]` property

- each object has an internal property called `[[prototype]]`, which is set to another object, the object's "prototype" object

- since objects are addressed by reference, any changes made to this prototype object will show up in the `[[prototype]]` property

- since the prototypes are objects themselves, they have their own `[[prototype]]` properties, linking to another prototype object, this chain is called a "prototype chain", the end of the chain is always the `null` object, `null` is the last prototype / commin ancestor to all objects

- any properties added to a prototype object will be available to all objects below in the prototype chain

- when accessing an object's property, JS first searches the own properties of the object, if no matching property is found it goes up the prototype chain searching through every prototype object until the first  match, if it reaches `null` it returns `undefined`, i.e. doesn't need to specify where in the prototype chain the property is, can use property as if it were own property of object

  -> Prototypal inheritance is actually more "delegation" than inheritance, since properties are only referenced and not copied

- since JS returns the firs tmatch when searching the prototype chain for a property, later properties "overshadow" earlier ones with the same name

- there can be various prototype chains, all ending at `null`, see later

<!-- first diagram Prototype chain - 1st try -->

- box: object
- connection: via object's `[[prototype]]` property

<!-- first diagram -->

- problem 1: by default the `[[prototype]]` properties of the objects are not chained to each other, would need to set it for each single object
- problem 2: changing the `[[prototype]]` property of an object is very inefficient operation, should not be done manually
- solution: constructors or `Object.create()`, see later

### The `prototype` property

- functions are objects and have like every other object a `[[prototype]]` property linking to a prototype object

- but they are special, because they have a second property called `prototype` which is set to yet another prototype object, can be the same prototype object as the `[[prototype]]` property, e.g. like the `Function` constructor has is, see later

- this other prototype object is part of a prototype chain as well

- this prototype object also has a property called `constructor` set to the function object for which it is a prototype, i.e. creating a circular reference

- when creating an object using a constructor, the `new` operator sets the `[[prototype]]` property of the new object to the `prototype` property of the constructor, i.e. exactly this second prototype object, (see step 2. in steps of the `new` operator) 

- so all instances of a constructor get this same object as their `[[prototype]]`, any changes made to it are instantly available to all instances, need only to add / change / remove properties in this single object accessible through constructor's `prototype` property

  -> enables inheritance

- can access constructor from every instance through the `constructor` property of the constructor's `prototype` property which is inherited to every instance, e.g. useful if doesn't know constructor's name but has a instance available

  ```javascript
  const car2 = new Car("Toyota", "Corolla", 1995); // via constructor
  const car2 = new car1.constructor(/*...*/); 		 // via instance, same result
  ```

<!-- second diagram Prototype chain - 2nd try -->

- box 1: object
- connection 1: via object's `[[prototype]]` property
- box 2: function object
- connection 2: via object's `prototype` property
- connection 3: via object's `constructor` property

<!-- second diagram -->

- by default a function's `prototype` property is linked to the `prototype` property of `Object` which is linked to `null`, see later how can change `prototype` property of constructors for multi-level inheritance
- object literals have their `[[prototype]]` property directly set to `Object.prototype`

<!-- third diagram Prototype chain - complete-->

- box 1: object
- connection 1: via object's `[[prototype]]` property
- box 2: function object
- connection 2: via object's `prototype` property
- connection 3: via object's `constructor` property
- box 3: built-in constructors

<!-- third diagram -->

### Summary

- every object has exactly one `[[prototype]]` property COLOR
- every function object has an additional one `prototype` property COLOR2
- `Object.prototype` is a common prototype of every typical object, (see later how can create different prototype chains using `Object.create()`)
- beware: don't simply add custom properties to `Object.prototype` since it pollutes the entire global prototype chain, instead create a single constructor for all your objects to inherit from and use its `prototype` propery to add desired properties
- a function object has by default `Function.prototype` as `[[prototype]]`
- an object literal has by default `Object.prototype` as `[[prototype]]`

### Data types as objects

- all data types in JS either are or behave like objects

- for each data type exists a constructor, holds relevant properties in its `prototype` property for all instances to inherit, e.g. `Object`, `Function`, `Array`, `String`, `Number`, `Boolean`
- data type constructors `Array`, `String`, `Number`, `Boolean` are like `Car` in above diagram, have their `prototype` properties linked to `Object.prototype` and their `[[prototype]]` properties to `Function.prototype`

- objects, functions, and arrays are objects, even if created using literals, no difference if created literally or using data type constructor
- strings, numbers, booleans are primitives if created literally, are no objects, different from data type constructors which create objects

- beware: don't create primitives using constructors, will not work as expected, e.g

  ```javascript
  "Hi" === new String("Hi") // false, since RHS is of type object
  Boolean(false) === true // true, since object is always truthy
  ```

- when using strings, numbers, or booleans like an object, e.g. accessing a method, JS silently creates a temporary "wrapper object" to perform the desired operation, makes primitives behave like objects e.g.

  ```javascript
  "Hello World!".toUpperCase() // "HELLO WORLD!"
  "  boat  \n".trim() // "boat"
  3.141592654.toFixed(2) // "3.14"
  3.141592654.toPrecision(3) // "3.14"
  ```

- wrapper objects are only one time use, are discarded immediately after use, i.e. can't use like objects to store data, e.g.

  ```javascript
  const str = "Hello";
  str.data = "abc";
  console.log(str.data); // undefined, already discarded
  ```

- data type constructors implement a `valueOf()` method in their `prototype` property, overshadows `Object.valueOf()`, returns the primitive value of the wrapper instance, e.g. `Boolean(false).valueOf()` gives primitive false value

- data type constructors implement a `toString()` method in their `prototype` property, overshadows `Object.toString()`, returns value as string, useful for all data types except for objects, returns only "[object type]", can use `JSON.stringify` instead to stringify object

### Accessing `[[prototype]]` property

- the `[[prototype]]` property of every object is internal, can not be accessed like a normal property
- `Object.get`/`set.PrototypeOf()`: prefered way
- `Object.prototype.__proto__`: legacy, inherited to all objects, is actually a getter / setter property
- still modifying prototype of an object is very slow operation, avoid if possible, instead of changing create new object with desired prototype using `Object.create()` (see later)

### Inherit properties

- add properties to custom constructor's prototype property, because

  - are available to all instances like own properties, but beware property shadowing
  - only way if wants to still modify / add / remove later
  - exist only once in prototype object instead of being copied to every instance

  ```javascript
  Car.prototype.sayHi = function() {console.log("Hi, my make is " + this.make);};
  car1.sayHi(); // "Hi, my make is Honda"
  car2.sayHi(); // "Hi, my make is Toyota"
  ```

- don't pollute default prototype chains by adding to built-in constructor's `prototype` properties, e.g. `Object.prototype`, instead create a single constructor for all your objects to inherit from and use its `prototype` propery to add desired properties

- properties added to constructor object itself instead of it's `prototype` property won't inherit to instances

- remember: `this` in a method refers to the calling object, i.e. especially not the prototype object the method is inherited from, e.g. in `car1.sayHi()`



## Multi-level inheritance

<!-- ToDo: write content -->



## Classes

- only syntactical sugar for same prototype-based inheritance, came with ES5





- "own properties" are properties of object itself, not from prototype chain
- properties can be set to enumerable, writable, etc.



- a constructor's `prototype` properties are available on every object instance of descendant object type, e.g. everything in `Object.prototype` is available in every object (if it's part of the standard prototype chain)



- can access properties of parent object without knowing its name, `Object.getPrototypeOf(car1).someProperty = asdljkfaösd` or delete it

- `Object.keys()`: returns array with own enumerable property names, can use array iteration ways
- `Object.getOwnPropertyNames()`: returns array with own property names including non-enumerable ones, but not Symbols
-  `Object.create()`



## Resources

- MDN - as usual