# Functions

[TOC]

<!-- ToDo: finish -->

## Functions

- reusable blocks of code
- just special objects: callable, additional `prototype` property, constructor of a function is `Function`, inherits some properties
- returns `undefined` by default, can change with `return` keyword

- functions in JS are first-class, can treat them like any other value, i.e. pass as argument, return, assigning to variable, storing in object, etc.

### Function definition

- function declaration or function expression

- parameters are not mandatory, if not provided are `undefined`, if more provided are ignored, can access all through array-like `arguments` object, to capture some but not all arguments in an array see rest parameter
- can give parameters a default value: `param1 = val1`

- function body contains the statements

#### Function declaration / statement

- function as a statement, in main code flow

```javascript
function identifier(param1, param2) {
  statements;
}
```

- name is mandatory

- does not end with a semicolon

- in non-strict mode is scoped to containing function, in strict mode to containing block

  ```javascript
  // containing scope is function a
  function a() {
    function b() {
      console.log("Hello World!");
    }
  }
  b(); // ReferenceError: b is not defined
  
  // containing scope is main code, since non-strict mode
  {
    function b() {
      console.log("Hello World!");
    }
  }
  b(); // "Hello World!"
  
  // containing scope is block, since strict mode
  "use strict";
  {
    function b() {
      console.log("Hello World!");
    }
  }
  b(); // ReferenceError: b is not defined
  ```

- hoisted to top of containing scope, i.e. can use function before declared it, see hoisting

- if containing scope is global scope, becomes property of global object, as if was defined using `var` function expression

- beware: declaring conditionally might not work as expected, use function expressions instead ❓

#### Function expression

- function as an expression, not in the main code flow, e.g. in variable assignment, function argument, return statement, object literal, etc.

  like function declaration but not in main code flow

  ```javascript
  // named function expression in assignment
  const a = function identifier(param1, param2) {
    statements;
  };
  
  // anonymous function expression in assignment
  const b = function (param1, param2) {
    statements;
  };
  ```

- name is optional, named or anonymous function expression, name is only accessible within the function expression, e.g. for recursion, and useful in debuggers

- not hoisted❗️(in variable assignment only variable itself is hoisted)

- IIFE: Immediately Invoked Function Expression

  ```javascript
  (function(param1, param2) {
    statements;
  }())
  ```

- arrow function

- arrow func: this is taken from outer scope, i.e. can use inside methods !!!!! ?????







## tmp

- pass function itself without parentheses, using parentheses calls it and returns only value, e.g. when creating a method from existing function, etc.
- 

- "each entry in the `arguments` object is a duplicate of each named argument. Note that the values are shared, but not the memory space. The two memory spaces are kept synchronized by the JavaScript engine"



## Closure

- name-binding: an association of a name to an entity, e.g. the association of an identifier to a variable
- scope: region of a computer program where a given name-binding is valid
- environment: mapping of non-local variables to their value / references in the enclosing scope, i.e. ???
- closure: record storing a function together with an environment, used to implement lexically scoped name binding (?)

closure allows the function to access those captured variables through the closure's copies of their values or references, even when the function is invoked outside their scope, e.g. if it was returned from within an outer function, still has access to variables

scope of inner function includes scope of outer function, even when outer function has returned

closure: ? scope of inner function continues even if outer function has already returned
closure: ? function scope, outer set closes around the inner set

---> reduce global variables as much as possible, use anonymous functions to wrap variables, use closure to return functions



- beware: returning a function from enclosing scope might behave differently than expected because if it accesses global variable

```javascript
// problem: i is always 100
var arr = [];
for (var i = 0; i < 100; i++) {
  // return function that accesses i
    arr[i] = function() { console.log(i); };
}
arr.forEach(item => {item()});
```

- explanation: because of closure each function has access to variables inside loop including `i`, but because `var` is global, `i` is actually the same for every function, now because by the time the functions are executed, the loop is already done and `i`'s last value was `100`, they all access the same `i` with value `100`

- solution: use `let` or wrap function in IIFE that is passed `i` as argument

  ```javascript
  // solution 1: use let to create block scope
  var arr = [];
  let (var i = 0; i < 100; i++) {
    // return function that accesses i
      arr[i] = function() { console.log(i); };
  }
  arr.forEach(item => {item()});
  
  // solution 2: use IIFE to create function scope
  var arr = [];
  for (var i = 0; i < 100; i++) {
    // return function that accesses i
      arr[i] = (function(index) {return function() { console.log(index); }}(i));
  }
  arr.forEach(item => {item()});
  ```

  

## Resources

- MDN - as usual