# Functions

[TOC]

<!-- ToDo: finish -->

## Functions

- reusable blocks of code
- just special objects: callable, additional `prototype` property, constructor of a function is `Function`, inherits some properties
- functions in JS are first-class, can treat them like any other value, i.e. pass as argument, return, assigning to variable, storing in object, etc., see later Function expression
- returns `undefined` by default, can change with `return` keyword

### Function definition

- can be function declaration / statement or function expression

- function argument contains the parameters, function body contains the statements

- parameters are not mandatory, if not provided are `undefined`, if more provided are ignored

- can access all parameters through array-like `arguments` object

  beware: in non-strict mode `arguments` object's elements are synchronized with parameters, changing either one changes the other, use strict mode to not synchronise

- can use rest syntax to capture multiple arguments in an array, see ellipsis operator

- can give parameters a default value using `param1 = val1`

- can use destructuring of arguments, see destructuring assignment

#### Function declaration / statement

- function as a statement, in main code flow

```javascript
function identifier(param1, param2) {
  statements;
}
```

- name is mandatory

- does not end with a semicolon

- in non-strict mode is scoped to containing function, in strict mode to containing block

  ```javascript
  // containing scope is function a
  function a() {
    function b() {
      console.log("Hello World!");
    }
  }
  b(); // ReferenceError: b is not defined
  
  // containing scope is main code, since non-strict mode
  {
    function b() {
      console.log("Hello World!");
    }
  }
  b(); // "Hello World!"
  
  // containing scope is block, since strict mode
  "use strict";
  {
    function b() {
      console.log("Hello World!");
    }
  }
  b(); // ReferenceError: b is not defined
  ```

- hoisted to top of containing scope, i.e. can use function before declared it, see hoisting

- if containing scope is global scope, becomes property of global object, as if was defined using `var` function expression

- beware: declaring conditionally might not work as expected, use function expressions instead ❓

#### Function expression

- function as an expression, not in the main code flow, e.g. in variable assignment, function argument, return statement, object literal, etc.

  ```javascript
// named function expression in assignment
  const a = function identifier(param1, param2) {
    statements;
  };
  
  // anonymous function expression in assignment
  const b = function (param1, param2) {
    statements;
  };
  ```
  
- name is optional, named or anonymous function expression, name is only accessible within the function expression, e.g. for recursion, and useful in debuggers

- not hoisted❗️(in variable assignment only variable itself is hoisted)

##### Arrow functions

- shorthand for function expression

  ```javascript
  // arrow function in assignment
  const identifier = (param1, param2) => {statements;};
  
  // shorthand for direct return statement
  									 			/*...*/		  => expression; // equivalent to {return expression;}
  
  // shorthand for single parameter
  														 param1 =>   /*...*/	 // equivalent to (param1)
  
  const multi = (a, b) => a*b;		// shorthand for (a, b) => {return a*b;}
  const double = x => x*2;				// shorthand for (x) => {return x*2;}
  const sayHello = () => {console.log("Hello World!")}
  ```

- doesn't have an `arguments` object

- no sepearte `this`, takes `this` from enclosing scope, i.e. can use inside a method❗️



## Function call

`identifier(param1, param2)`

- `this` is determined by how the function is called, see `this` keyword, call with `Function.prototype.call()` to specify `this`, also `Function.prototype.apply()` takes array of arguments

- can use spread syntax to call with multiple values from iterable, see ellipsis operator
- callback: function that is passed as argument into another function, is "called back" later in this other function
- to pass function itself, no parentheses, using parentheses calls it and returns only value, e.g. when creating a method from existing function, attaching event handler, etc.

#### IIFE (Immediately Invoked Function Expression)

```javascript
(function(param1, param2) {
  statements;
}())
```

- can be used to create scope, e.g. to hide variables from outer scope, to correct reference, see later Closure



## (Lexical / Static) Scope

- entity: everything that you can assign an identifier to, e.g. variable, function, etc.

- name-binding: an association of a name to an entity, e.g. the association of an identifier to a variable

- scope of a name-binding: region of the source code where a given name-binding is valid, in different scopes a name-binding can refer to different entities

- scope: region of the source code which can be the scope of name-bindings

- in JS a scope is created by a function and a block, not only after name-binding is defined, i.e. variables and functions are hoisted to top of containing scope

  ```javascript
  // scope of a
  function a() {
    var x = 42;
    console.log(x); // 21
  }
  a();
  
  // global scope
  console.log(x); // ReferenceError: x is not defined
  
  // scope of b
  function b() {
    var x = 21;
    console.log(x); // 10.5
  }
  b();
  ```

- `var` variables are contained to function scope, `let` / `const` are also contained to block scope

- local variable: variable that is defined in the local scope

- non-local variable: variable that is not defined in the local scope, e.g. in enclosing function

- an inner scope has access to the outer scope, but outer scope doesn't have access to inner, i.e. inner function has access to all outer scopes until global scope because of recursive argument

  ```javascript
  var x = 42;
  
  function a() {
    var y = 21;
    
    function b() {
      var z = 1;
      console.log(x, y, z); // 42, 21, 1
    }
    b();
    
    console.log(x, y); // 42, 21, z not defined
  }
  a();
  
  console.log(x); // 42, y,z not defined
  ```

- local variables override non-local variables with the same name

  ```javascript
  var x = 42;
  
  function a() {
    var x = 21;
    console.log(x); // 21
  }
  a();
  ```



## (Lexical) Closure

- problem: implementing scope with first-class functions, because with first-class functions the inner scope can live longer than the outer scope and depend on non-local variables, e.g. if an outer function returned an inner function, or if inner function is saved and called later, e.g. as event handler, as argument to async function like `setTimeout()`, etc.
- solution: maintain record of non-local variables a function can depend on
- environment: record of non-local name-bindings, e.g. the variables the function (may) depend on

- closure: record of a function together with an environment, created every time a function is created 

- an entity is only garbage collected if there are no more references to it from existing closures

- often refers colloquially to function itself as "closure"

```javascript
// returned function depends on non-local variable x
function a() {
  const x = 42;
  return function() {console.log(x);};
}

const b = a();
b(); // 42
```

- using closure and IIFE can create private entities, i.e. to hide from global namespace / not clutter it

```javascript
const container = (function () {
  // state variables here
  return function(...) {
    // depends on state variables here
  };
}())

const b = (function() {
  const x = 42;
  return function() {console.log(x);};
}());
b(); // 42

const nameContainer = (function() {
  const names = ["Tick", "Trick", "Track"];
  return function(n) {
    return names[n];
  }
}());

function createAdder(x) {
  return function(y) {
    return x + y;
  };
}
let add5to = createAdder(5); // closure of x = 5
console.log(add5to(3)); // 8


```

- using closure and IIFE can create generators, i.e. return different values each time they're called

```javascript
function factory(...) {
  // generator's state variables
  return function() {
    // update state variables and return new value
  }
}
const generator = factory(...);

function counter() {
  let i = 0;
  return function () {
    index += 1;
    return index;
  }
}
const generator = counter();
console.log(generator()); // 1
console.log(generator()); // 2
console.log(generator()); // 3

function element(arr) {
  let i = 0;
  return function() {
    if (i < arr.length) {
      const item = arr[i];
      i += 1;
      return item;
    }
  }
}
const generator = element(["Hello", "World", 420]);
console.log(generator()); // "Hello"
console.log(generator()); // "World"
console.log(generator()); // 420
console.log(generator()); // undefined
```

### Common error

- although each function has its individual closure, its environment must not be distinct, can lead to errors when environment is mistakenly expected to be distinct
- commonly functions created in a loop depending on non-block-scoped variables, e.g. when attaching event handlers, scheduling `setTimeout` calls, etc.
- one reason more to always use block-scoped variables, or create new function scope by wrapping in IIFE

#### Example problem

- use loop to put `100` functions into an array which log `i` when called later
- problem: `i` is always `100`

```javascript
var arr = [];
for (var i = 0; i < 100; i++) {
    arr[i] = function() {console.log(i);}; // function depending on i
}
arr.forEach(item => {item()}); // i is always 100
```

#### explanation

- because of closure each function has access to the non-local variables, here it's only the single same `i` (independently of value of `i` at time of assignment) because `i` is `var` and has function scope (here: global scope) and not block scope (here: for loop), in other words the function's environment is identical
- by the time the value of `i` is determined the loop has already run and `i` has the last value `100``
- ``arr[i]` is working because the value of `i` is evaluated at that time instead of in the functions later after the loop has finished

#### solution

- solution 1: use `let` to make `i` block-scoped

- now the function's environments all contain different `i`'s, namely the `i` of the respective iteration

  ```javascript
  var arr = [];
  let (let i = 0; i < 100; i++) {
      arr[i] = function() {console.log(i);};
  }
  arr.forEach(item => {item()});
  ```
  

- solution 2: use IIFE to create nested function scope with local `i` (renamed to `index` for clarification)

- now the value of `i` is determined at time of the IIFE execution, similarly how `arr[i]` works

  ```javascript
  var arr = [];
  for (var i = 0; i < 100; i++) {
      arr[i] = (function(index) {
        return function() {console.log(index);}
      }(i));
  }
  arr.forEach(item => {item()});
  ```

- solution 3 (only works with arrays): use `Array.prototype.forEach()` instead of for loop, `i` is scoped to iteration like in for loop with `let`

  ```javascript
  var arr = Array.from(Array(100));
  arr.forEach((item, i) => {arr[i] = function() {console.log(i)};});
  
  arr.forEach(item => {item()});
  ```

  

## Built-in functions

### Global functions

- `eval()`: runs JS code from string, slow and insecure, never use ⚠️
- `isNaN()`: checks if value is `NaN`, uses coercion for non-number data types, many false positives, use newer `Number.isNaN()` instead ⚠️
- `isFinite()`: false if value is `Infinity`, `NaN` or `undefined`

### `Function` object type

- `Function.prototype.call()`: calls function with specified object as `this`, arguments as list
- `Function.prototype.apply()`: calls function with specified object as `this`, arguments as array



## Resources

- MDN - as usual