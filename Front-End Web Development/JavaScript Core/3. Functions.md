# Functions

[TOC]



## Introduction

- reusable blocks of code
- just special objects: callable, additional `prototype` property, constructor of a function is `Function`, inherits some properties
- functions in JS are first-class, can treat them like any other value, i.e. pass as argument, return, assigning to variable, storing in object, etc., see later Function expression
- returns `undefined` by default, can change with `return` keyword



## Function definition

- can be function declaration / statement or function expression
- function argument contains the parameters, function body contains the statements
- parameters are not mandatory, if not provided are `undefined`, if more provided are ignored
- can access all parameters through array-like `arguments` object  
  beware: in non-strict mode `arguments` object's elements are synchronized with parameters, changing either one changes the other, use strict mode to not synchronise
- can use rest syntax to capture multiple arguments in an array, see ellipsis operator
- can give parameters a default value using `param1 = val1`
- can use destructuring of arguments, see destructuring assignment
- beware: don't use `Function` constructor to create a function, creates in global scope only, i.e. don't have closures, is parsed only on creation instead of in advance, doesn't allow for optimisation because function body is string, slow ❗️

### Function declaration / statement

- function as a statement, in main code flow

```javascript
function identifier(param1, param2) {
  statements;
}
```

- name is mandatory
- does not end with a semicolon
- in non-strict mode is scoped to containing function, in strict mode to containing block

```javascript
// containing scope is function a
function a() {
  function b() {
    console.log("Hello World!");
  }
}
b(); // ReferenceError: b is not defined

// containing scope is main code, since non-strict mode
{
  function b() {
    console.log("Hello World!");
  }
}
b(); // "Hello World!"

// containing scope is block, since strict mode
"use strict";
{
  function b() {
    console.log("Hello World!");
  }
}
b(); // ReferenceError: b is not defined
```

- hoisted to top of containing scope, i.e. can use function before declared it, see hoisting
- behaves as if was defined using `var` function expression except that body is also hoisted, i.e. if defined in global scope becomes property of global object, one of the bad qirks of JS ❗️
- beware: don't declare functions in conditional block in non-strict mode, behavior differs across implementations, instead use function expressions and/or strict mode ❗️

```javascript
if (true) {
  function x() {return 42;}
}
else {
  function x(){ return 21;}
}
x(); // 42 in FF 72, Chrome 79
      // 21 in Safari 13
```

  

### Function expression

- function as an expression, not in the main code flow, e.g. in variable assignment, function argument, return statement, object literal, etc.
- not hoisted ❗️(also in variable assignment only variable itself is hoisted)
- if used as an assignmend, is scoped to containing function or block depending on `var`, `let`, or `const`

#### Named

- name is only accessible within the function expression, e.g. for recursion, also helpful because it shows up in stack traces

```javascript
// named function expression in assignment
const a = function identifier(param1, param2) {
  statements;
};
```

#### Anonymous

- name is optional, function expression can be "anonymous"

```javascript
// anonymous function expression in assignment
const a = function (param1, param2) {
  statements;
};
  ```

#### Arrow function

- shorthand for anonymous function expression (since ES6)

```javascript
// arrow function in assignment
const identifier = (param1, param2) => {statements;};

// shorthand for direct return statement
                            /*...*/ => expression; // equivalent to {return expression;}

// shorthand for single parameter
                             param1 => /*...*/     // equivalent to (param1)

const multi = (a, b) => a*b;    // shorthand for (a, b) => {return a*b;}
const double = x => x*2;        // shorthand for (x) => {return x*2;}
const sayHello = () => {console.log("Hello World!")}
```

- direct return shorthand interferes with block body syntax when returning object literals, wrap in parentheses instead, e.g. `() => ({x: 1})`
- do not have a `prototype` property, i.e. can't be used as constructor with `new`
- doesn't have a `this`, `arguments`, or `super` object
- takes `this` from enclosing scope, like any other non-local variable, not bound to parents `this` but whatever enclosing scope is ❗️
- can use arrow function as function inside a method without needing to bind `this`, but not as method itself because `this` would be global object ❗️ 

```javascript
// inside constructor 'this' context is newly created object
function Person(name) {
  this.name = name;
  this.sayHi = function() {
    console.log("Hi, my name is " + this.name);};
  this.sayHi2 = () => {
    console.log("Hi, my name is " + this.name);};
}

const p = new Person("Peter");
p.sayHi();  // Hi, my name is Peter
p.sayHi2(); // Hi, my name is Peter

const q = {
  name: "Sarah",
  sayHi: p.sayHi,
  sayHi2: p.sayHi2
};

q.sayHi(); // Hi, my name is Sarah
q.sayHi2(); // Hi, my name is Peter
```

```javascript
// outside constructor 'this' context is global object / undefined
function Person(name) {
  this.name = name;
}

Person.prototype.sayHi = function() {
  console.log("Hi, my name is " + this.name);};
Person.prototype.sayHi2 = () => {
  console.log("Hi, my name is " + this.name);};

const p = new Person("Peter");
p.sayHi(); // Hi, my name is Peter
p.sayHi2(); // Hi, my name is

const q = {
  name: "Sarah",
  sayHi: p.sayHi,
  sayHi2: p.sayHi2
};

q.sayHi(); // Hi, my name is Sarah
q.sayHi2(); // Hi, my name is
```



## Function call

`identifier(param1, param2)`

- can use spread syntax to call with multiple values from iterable, see ellipsis operator
- arguments are passed by value, for objects the object reference is passed as value, i.e. outside objects can be modified from within the function ❗️
- `this` is determined by how the function is called, see `this` keyword, call with `Function.prototype.call()` to specify `this`, also `Function.prototype.apply()` takes array of arguments
- callback: function that is passed as argument into another function, is "called back" later in this other function
- to pass function itself, no parentheses, using parentheses calls it and returns only value, e.g. when creating a method from existing function, attaching event handler, etc.

#### IIFE (Immediately Invoked Function Expression)

```javascript
(function(param1, param2) {
  statements;
}())
```

- can be used to create scope, e.g. to hide variables from outer scope, to correct reference, see later Closure
- parentheses needed to distinguish it from invalid function declaration



## (Lexical / Static) Scope

- entity: everything that you can assign an identifier to, e.g. variable, function, etc.
- name-binding: an association of a name to an entity, e.g. the association of an identifier to a variable
- scope: region of the source code where a name-binding is valid, in different scopes the name-binding can refer to different entities, e.g. region where a variable can be referenced
- in JS a scope is created by a function and a block, not only after name-binding is defined, i.e. variables and functions are "hoisted" to top of containing scope

```javascript
function a() {
  // scope of a
  var x = 42;
  console.log(x); // 42
}
a();

// global scope
console.log(x); // ReferenceError: x is not defined

function b() {
  // scope of b
  var x = 21;
  console.log(x); // 21
}
b();
```

- `var` variables are contained only to function scope, `let` / `const` are also contained to block scope
- beware: JS has block scope-like syntax using curly braces, but `var` is not block scoped, e.g. `i` in `for (var i = 0; ...) {...}` is a global variable, keeps existing in outside scope, prefer `let` and `const` at all times ⚠️
- local variable: variable that is defined in the scope in question
- non-local variable: variable that is not defined in the scope in question, e.g. in enclosing function
- an inner scope has access to the outer scope, but outer scope doesn't have access to inner, i.e. inner function has access to all outer scopes until global scope because of recursive argument

```javascript
var x = 42;

function a() {
  var y = 21;
  
  function b() {
    var z = 1;
    console.log(x, y, z); // 42, 21, 1
  }
  b();
  
  console.log(x, y); // 42, 21, z not defined
}
a();

console.log(x); // 42, y,z not defined
```

- local variables override non-local variables with the same name

```javascript
var x = 42;

(function() {
  var x = 21;
  console.log(x); // 21
}());

console.log(x); // 42
```



## (Lexical) Closure

- problem: implementing scope with first-class functions, because with first-class functions the inner scope can live longer than the outer scope and depend on non-local variables, e.g. if an outer function returned an inner function, or if inner function is saved and called later, e.g. as event handler, as argument to async function like `setTimeout()`, etc.
- solution: maintain record of non-local variables a function can depend on
- environment: record of non-local name-bindings, e.g. the variables the function (may) depend on, i.e. record of lexical scope the function was defined in
- closure: record of a function together with its environment, created every time a function is created
- an entity is only garbage collected if there are no more references to it from existing closures
- often refers to the environment and also the function itself as "closure"
- allows function to access its lexical scope even when it is executed in a different scope, e.g. most often a more outer scope, preserves access to variables

```javascript
// returned function depends on non-local variable x
function a() {
  const x = 42;
  return function() {console.log(x);};
}

const b = a();
b(); // 42
```

- the name-bindings in the environment give the actual values, i.e. closure is not just a snapshot of the scope at time of creation, doesn't capture a value, instead preserves access to variable, can not "close over" a value but only a variable ❗️

```javascript
function wrap() {
  let x = 42;
  function a() {
    return function() {console.log(x);};
  }
  x = 21;
  return a;
}

const b = wrap()();
b(); // 21
```

- using closure and IIFE can create private entities, i.e. to hide from global namespace / not clutter it

```javascript
const container = (function () {
  // state variables here
  return function(...) {
    // depends on state variables here
  };
}())

const b = (function() {
  const x = 42;
  return function() {console.log(x);};
}());
b(); // 42

const nameContainer = (function() {
  const names = ["Tick", "Trick", "Track"];
  return function(n) {
    return names[n];
  }
}());

function createAdder(x) {
  return function(y) {
    return x + y;
  };
}
let add5to = createAdder(5); // closure of x = 5
console.log(add5to(3)); // 8
```

- using closure and IIFE can create generators, i.e. return different values each time they're called

```javascript
function factory(...) {
  // generator's state variables
  return function() {
    // update state variables and return new value
  }
}
const generator = factory(...);

function counter() {
  let i = 0;
  return function () {
    index += 1;
    return index;
  }
}
const generator = counter();
console.log(generator()); // 1
console.log(generator()); // 2
console.log(generator()); // 3

function element(arr) {
  let i = 0;
  return function() {
    if (i < arr.length) {
      const item = arr[i];
      i += 1;
      return item;
    }
  }
}
const generator = element(["Hello", "World", 420]);
console.log(generator()); // "Hello"
console.log(generator()); // "World"
console.log(generator()); // 420
console.log(generator()); // undefined
```

- using closure can replace classes to create pipes, e.g. like jQuery object, Gulp pipes, etc.

```javascript
// functional style
function foo() {
  let counter = 0;

  const bar = {
    inc() {
      counter += 1;
      return bar;
    },

    print() {
      console.log(counter);
      return bar;
    }
  };

  return bar;
}

foo()
  .inc()
  .inc()
  .print() // 2
  .inc()
  .print(); // 3

// class style
class bar {
  #counter = 0;

  inc() {
    this.#counter += 1;
    return this;
  }

  print() {
    console.log(this.#counter);
    return this;
  }
}

new bar()
  .inc()
  .inc()
  .print() // 2
  .inc()
  .print(); // 3
```

### Common error

- although each function has its individual closure, its environment must not be distinct, can lead to errors when environment is mistakenly expected to be distinct
- commonly functions created in a loop depending on non-block-scoped variables, e.g. when attaching event handlers, scheduling `setTimeout` calls, etc.
- one reason more to always use block-scoped variables, or create new function scope by wrapping in IIFE

#### Example problem

- use loop to put `100` functions into an array which log `i` when called later
- problem: `i` is always `100`

```javascript
var arr = [];
for (var i = 0; i < 100; i++) {
    arr[i] = function() {console.log(i);}; // function depending on i
}
arr.forEach(item => {item();}); // i is always 100
```

#### explanation

- because of closure each function has access to the non-local variables, here it's only the single same `i` (independently of value of `i` at time of assignment) because `i` is `var` and has function scope (here: global scope) and not block scope (here: for loop), in other words the function's environments are all identical
- by the time the value of `i` is determined the loop has already run and `i` has the last value `100``
- `arr[i]` works though because the value of `i` is evaluated at that time instead of in the functions later after the loop has finished

#### solution

- solution 1: use `let` to make `i` block-scoped
- now the function's environments all contain different `i`'s, namely the `i` of the respective iteration

```javascript
var arr = [];
for (let i = 0; i < 100; i++) {
    arr[i] = function() {console.log(i);};
}
arr.forEach(item => {item();});
```
  
- solution 2: use IIFE to create nested function scope with local `i` (renamed to `index` for clarification)
- now the value of `i` is determined at time of the IIFE execution, similarly how `arr[i]` works

```javascript
var arr = [];
for (var i = 0; i < 100; i++) {
    arr[i] = (function(index) {
      return function() {console.log(index);}
    }(i));
}
arr.forEach(item => {item();});
```

- solution 3 (only works with arrays): use `Array.prototype.forEach()` instead of for loop, `i` is scoped to iteration like in for loop with `let`

```javascript
var arr = Array.from(Array(100));
arr.forEach((item, i) => {arr[i] = function() {console.log(i)};});

arr.forEach(item => {item();});
```



## Built-in functions

### Global functions

- `eval()`: runs JS code from string, slow and insecure, never use ⚠️
- `isNaN()`: checks if value is `NaN`, uses coercion for non-number data types, many false positives, use newer `Number.isNaN()` instead ⚠️
- `isFinite()`: false if value is `Infinity`, `NaN` or `undefined`

### `Function` object type

- `Function.prototype.call()`: calls function with specified object as `this`, arguments as list
- `Function.prototype.apply()`: calls function with specified object as `this`, arguments as array



## Resources

- MDN - as usual