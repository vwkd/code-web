# Functions

[TOC]

## Introduction

- reusable blocks of code
- just special objects: callable, additional `prototype` property, constructor of a function is `Function`, inherits some properties
- functions in JS are first-class, can treat them like any other value, i.e. pass as argument, return, assigning to variable, storing in object, etc., see later Function expression
- returns `undefined` by default, can change with `return` keyword



## Function definition

- can be function declaration / statement or function expression

- function argument contains the parameters, function body contains the statements

- parameters are not mandatory, if not provided are `undefined`, if more provided are ignored

- can access all parameters through array-like `arguments` object

  beware: in non-strict mode `arguments` object's elements are synchronized with parameters, changing either one changes the other, use strict mode to not synchronise

- can use rest syntax to capture multiple arguments in an array, see ellipsis operator

- can give parameters a default value using `param1 = val1`

- can use destructuring of arguments, see destructuring assignment

- beware: don't use `Function` constructor to create a function, creates in global scope only, i.e. don't have closures, is parsed only on creation instead of in advance, doesn't allow for optimisation because function body is string, slow❗️

### Function declaration / statement

- function as a statement, in main code flow

```javascript
function identifier(param1, param2) {
  statements;
}
```

- name is mandatory

- does not end with a semicolon

- in non-strict mode is scoped to containing function, in strict mode to containing block

  ```javascript
  // containing scope is function a
  function a() {
    function b() {
      console.log("Hello World!");
    }
  }
  b(); // ReferenceError: b is not defined
  
  // containing scope is main code, since non-strict mode
  {
    function b() {
      console.log("Hello World!");
    }
  }
  b(); // "Hello World!"
  
  // containing scope is block, since strict mode
  "use strict";
  {
    function b() {
      console.log("Hello World!");
    }
  }
  b(); // ReferenceError: b is not defined
  ```

- hoisted to top of containing scope, i.e. can use function before declared it, see hoisting

- behaves as if was defined using `var` function expression except that body is also hoisted, i.e. if defined in global scope becomes property of global object, one of the bad qirks of JS❗️

- beware: don't declare functions in conditional block in non-strict mode, behavior differs across implementations, instead use function expressions and/or strict mode ❗️

  ```javascript
  if (true) {
    function x() {return 42;}
  }
  else {
    function x(){ return 21;}
  }
  x(); // 42 in FF 72, Chrome 79
       // 21 in Safari 13
  ```

  

### Function expression

- function as an expression, not in the main code flow, e.g. in variable assignment, function argument, return statement, object literal, etc.
- not hoisted❗️(also in variable assignment only variable itself is hoisted)
- if used as an assignmend, is scoped to containing function or block depending on `var`, `let`, or `const`

#### Named

- name is only accessible within the function expression, e.g. for recursion, also helpful because it shows up in stack traces

  ```javascript
  // named function expression in assignment
  const a = function identifier(param1, param2) {
    statements;
  };
  ```

#### Anonymous

- name is optional, function expression can be "anonymous"

  ```javascript
  // anonymous function expression in assignment
  const a = function (param1, param2) {
    statements;
  };
  ```

#### Arrow function

- shorthand for anonymous function expression

  ```javascript
  // arrow function in assignment
  const identifier = (param1, param2) => {statements;};
  
  // shorthand for direct return statement
  									 			/*...*/		  => expression; // equivalent to {return expression;}
  
  // shorthand for single parameter
  														 param1 =>   /*...*/	 // equivalent to (param1)
  
  const multi = (a, b) => a*b;		// shorthand for (a, b) => {return a*b;}
  const double = x => x*2;				// shorthand for (x) => {return x*2;}
  const sayHello = () => {console.log("Hello World!")}
  ```

- direct return shorthand interferes with block body syntax when returning object literals, wrap in parentheses instead, e.g. `() => ({x: 1})`

- doesn't have an `arguments` object

- no sepearte `this`, takes `this` from enclosing scope, i.e. can use as function inside a method without needing to specify `this`, but not as method itself because `this´ would be global object❗️

- do not have a `prototype` property, i.e. can't be used as constructor with `new`



## Function call

`identifier(param1, param2)`

- can use spread syntax to call with multiple values from iterable, see ellipsis operator
- arguments are passed by value, for objects the object reference is passed as value, i.e. outside objects can be modified from within the function❗️

- `this` is determined by how the function is called, see `this` keyword, call with `Function.prototype.call()` to specify `this`, also `Function.prototype.apply()` takes array of arguments
- callback: function that is passed as argument into another function, is "called back" later in this other function
- to pass function itself, no parentheses, using parentheses calls it and returns only value, e.g. when creating a method from existing function, attaching event handler, etc.

#### IIFE (Immediately Invoked Function Expression)

```javascript
(function(param1, param2) {
  statements;
}())
```

- can be used to create scope, e.g. to hide variables from outer scope, to correct reference, see later Closure
- parentheses needed to distinguish it from invalid function declaration



## (Lexical / Static) Scope

- entity: everything that you can assign an identifier to, e.g. variable, function, etc.

- name-binding: an association of a name to an entity, e.g. the association of an identifier to a variable

- scope of a name-binding: region of the source code where a given name-binding is valid, in different scopes a name-binding can refer to different entities, e.g. region where a variable can be referenced

- scope: region of the source code which can be the scope of name-bindings

- in JS a scope is created by a function and a block, not only after name-binding is defined, i.e. variables and functions are hoisted to top of containing scope

  ```javascript
  // scope of a
  function a() {
    var x = 42;
    console.log(x); // 21
  }
  a();
  
  // global scope
  console.log(x); // ReferenceError: x is not defined
  
  // scope of b
  function b() {
    var x = 21;
    console.log(x); // 10.5
  }
  b();
  ```

- `var` variables are contained to function scope, `let` / `const` are also contained to block scope

- beware: JS has block scope-like syntax using curly braces, but `var` is not block scoped, e.g. `i` in `for (var i = 0; ...) {...}` is a global variable, keeps existing in outside scope, prefer `let` and `const` at all times ⚠️

- local variable: variable that is defined in the scope in question

- non-local variable: variable that is not defined in the scope in question, e.g. in enclosing function

- an inner scope has access to the outer scope, but outer scope doesn't have access to inner, i.e. inner function has access to all outer scopes until global scope because of recursive argument

  ```javascript
  var x = 42;
  
  function a() {
    var y = 21;
    
    function b() {
      var z = 1;
      console.log(x, y, z); // 42, 21, 1
    }
    b();
    
    console.log(x, y); // 42, 21, z not defined
  }
  a();
  
  console.log(x); // 42, y,z not defined
  ```

- local variables override non-local variables with the same name

  ```javascript
  var x = 42;
  
  (function() {
    var x = 21;
    console.log(x); // 21
  }());
  
  console.log(x); // 42
  ```



## (Lexical) Closure

- problem: implementing scope with first-class functions, because with first-class functions the inner scope can live longer than the outer scope and depend on non-local variables, e.g. if an outer function returned an inner function, or if inner function is saved and called later, e.g. as event handler, as argument to async function like `setTimeout()`, etc.
- solution: maintain record of non-local variables a function can depend on
- environment: record of non-local name-bindings, e.g. the variables the function (may) depend on

- closure: record of a function together with an environment, created every time a function is created 

- an entity is only garbage collected if there are no more references to it from existing closures

- often refers colloquially to function itself as "closure"

```javascript
// returned function depends on non-local variable x
function a() {
  const x = 42;
  return function() {console.log(x);};
}

const b = a();
b(); // 42
```

- using closure and IIFE can create private entities, i.e. to hide from global namespace / not clutter it

```javascript
const container = (function () {
  // state variables here
  return function(...) {
    // depends on state variables here
  };
}())

const b = (function() {
  const x = 42;
  return function() {console.log(x);};
}());
b(); // 42

const nameContainer = (function() {
  const names = ["Tick", "Trick", "Track"];
  return function(n) {
    return names[n];
  }
}());

function createAdder(x) {
  return function(y) {
    return x + y;
  };
}
let add5to = createAdder(5); // closure of x = 5
console.log(add5to(3)); // 8


```

- using closure and IIFE can create generators, i.e. return different values each time they're called

```javascript
function factory(...) {
  // generator's state variables
  return function() {
    // update state variables and return new value
  }
}
const generator = factory(...);

function counter() {
  let i = 0;
  return function () {
    index += 1;
    return index;
  }
}
const generator = counter();
console.log(generator()); // 1
console.log(generator()); // 2
console.log(generator()); // 3

function element(arr) {
  let i = 0;
  return function() {
    if (i < arr.length) {
      const item = arr[i];
      i += 1;
      return item;
    }
  }
}
const generator = element(["Hello", "World", 420]);
console.log(generator()); // "Hello"
console.log(generator()); // "World"
console.log(generator()); // 420
console.log(generator()); // undefined
```

### Common error

- although each function has its individual closure, its environment must not be distinct, can lead to errors when environment is mistakenly expected to be distinct
- commonly functions created in a loop depending on non-block-scoped variables, e.g. when attaching event handlers, scheduling `setTimeout` calls, etc.
- one reason more to always use block-scoped variables, or create new function scope by wrapping in IIFE

#### Example problem

- use loop to put `100` functions into an array which log `i` when called later
- problem: `i` is always `100`

```javascript
var arr = [];
for (var i = 0; i < 100; i++) {
    arr[i] = function() {console.log(i);}; // function depending on i
}
arr.forEach(item => {item()}); // i is always 100
```

#### explanation

- because of closure each function has access to the non-local variables, here it's only the single same `i` (independently of value of `i` at time of assignment) because `i` is `var` and has function scope (here: global scope) and not block scope (here: for loop), in other words the function's environment is identical
- by the time the value of `i` is determined the loop has already run and `i` has the last value `100``
- ``arr[i]` is working because the value of `i` is evaluated at that time instead of in the functions later after the loop has finished

#### solution

- solution 1: use `let` to make `i` block-scoped

- now the function's environments all contain different `i`'s, namely the `i` of the respective iteration

  ```javascript
  var arr = [];
  let (let i = 0; i < 100; i++) {
      arr[i] = function() {console.log(i);};
  }
  arr.forEach(item => {item()});
  ```
  
- solution 2: use IIFE to create nested function scope with local `i` (renamed to `index` for clarification)

- now the value of `i` is determined at time of the IIFE execution, similarly how `arr[i]` works

  ```javascript
  var arr = [];
  for (var i = 0; i < 100; i++) {
      arr[i] = (function(index) {
        return function() {console.log(index);}
      }(i));
  }
  arr.forEach(item => {item()});
  ```

- solution 3 (only works with arrays): use `Array.prototype.forEach()` instead of for loop, `i` is scoped to iteration like in for loop with `let`

  ```javascript
  var arr = Array.from(Array(100));
  arr.forEach((item, i) => {arr[i] = function() {console.log(i)};});
  
  arr.forEach(item => {item()});
  ```

  

## Built-in functions

### Global functions

- `eval()`: runs JS code from string, slow and insecure, never use ⚠️
- `isNaN()`: checks if value is `NaN`, uses coercion for non-number data types, many false positives, use newer `Number.isNaN()` instead ⚠️
- `isFinite()`: false if value is `Infinity`, `NaN` or `undefined`

### `Function` object type

- `Function.prototype.call()`: calls function with specified object as `this`, arguments as list
- `Function.prototype.apply()`: calls function with specified object as `this`, arguments as array



## Resources

- MDN - as usual