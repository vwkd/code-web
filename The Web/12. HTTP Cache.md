# HTTP cache

[TOC]


<!-- ToDo: finish -->

## Introduction

- proxy server that temporarily serves stored response from similar previous request
- forwards request it hasn't seen already, stores response for a certain amount of time
- intercepts request that it has seen already, serves stored response for that certain amount of time
- can be private or public
- advantages:
  - fast, because loads local data instead of fetching remote data
  - efficient, because reduces load on network and server
- disadvantages:
  - complex, because needs to update at right time to not end up with outdated content
  - risky, because Web server can not ask proxy server to update (except public proxies that it can control)



## Cacheable responses

two problems:
similarity, to which request which response
duration, how long to serve cached response

request must be similar, same URL, same method, 

- can only cache resources that don't change
- only for `GET` HTTP method because safe (and has response body)
- only for sub-`5xx` HTTP status code because server error

<!-- ToDo: update below, only in certain conditions, safe method, headers etc -->

caches response body for given URL, safe method (i.e. GET) and certain status codes
before every request checks cache if has response for given URL
prevents unnecessary network requests

cache stores response body, identifies cache entry by URL
  if response can vary depending on content negotiation, might serve incompatible cache entry
  beware: usually content negotiation doesn't change for end user, can leave out `Vary`, only use if there is public proxy cache on the way
  needs to include `Vary` response header for name of header fields that can vary, e.g. `Vary: Accept-Language`
  but cache also needs to normalise value of varied header, because can be different for different UAs, e.g. for `Accept-Language` could be `fr-FR` or `fr_FR`, etc.



## Public / shared cache

- HTTP cache on network, e.g. ISP, CDN, before Web server, etc.
- serves multiple users
- can only cache non-personalised responses
- used often in front of dynamic Web server



## Private cache

- HTTP cache on client, e.g. Browser cache, Service Worker, etc.
- serves single user
- can also cache personalised responses
- used in every client

beware: all network requests from client, e.g. URL bar, hyperlinks, resources, Fetch API, etc.

- beware: can not rely on cache, resources may be deleted early, e.g. limited disk space, user action, etc. ❗️
- beware: manual refresh by user requests resource from server even if cache hit, but conditional request if revalidation tags ❗️

### On client

can cache manually using Service worker
can bypass / update cache using Fetch API and `cache` property of options






### On server

HTML can't be cached long

REST API responses can be cached
GraphQL API responses can't be cached

### Freshness

- duration a cached response is kept
- set via `Cache-Control` response header `max-age`
- relative to response time
- beware: don't leave out, otherwise proxy will use a default

- beware: during duration Web server can not update resource on proxy (except if on public proxy that it can control)
beware: don't just reuse a smallish `Cache-Control`, can't invalidate cache if a resource changed earlier, website can even break if doesn't refetch interdependent resource to one that isn't cached (or was deleted from cache) ⚠️

<!-- todo: update hypertext document + linked resource ==> two inder-dependent resources (e.g. hypertext document and CSS) -->

beware: careful what caches, if caches hypertext document but not linked resources, can break website because newer resources with old hypertext document
never change linked resources for a hypertext document that is allowed to be cached

but can version URLs of resources, e.g. hash in filename
must serve old resource at least as long as the caching time of the inter-dependency from the time of change

instead can version URL of resource
set expiration time to maximum value, i.e. one year `Cache-Control: max-age=31536000`
if resource changes, updates URL
beware: this doesn't work for hypertext documents since URL would change, can only do for linked resources, updates hypertext document and proxy refetches because are new, e.g. `.css`, `.js`, etc.
can automate in build process
then can cache hypertext document again

### Revalidation

after cached resource expired, proxy can try to revalidate before discarding it
- validates cache before discarding, instead of always requesting new resource
conditional request
- after cache expires, instead of fetching again, can ask if changed and if not can reuse existing cache

- set via `Cache-Control` response header `no-cache` and `must-revalidate`
  `no-cache`: revalidate before using cache, i.e. misnomer, doesn't mean "no cache"
  `must-revalidate`: revalidate after expired, i.e. misnomer, doesn't mean "must revalidate"

needs to send fingerprint of resource in `ETag` response header (or `Last-Modified`)
doesn't matter what it is, usually it's hash of content

proxy sends conditional request using `If-None-Match` (or `If-Modified-Since`) request header with fingerprint of resource
Web server sends resource if fingerprint changed
otherwise sends `304 Not Modified` with empty body and new `Cache-Control` header until which proxy reuses cache


<!-- vvv OLD OLD OLD vvv -->

can set `Cache-Control` RESPONSE header for duration relative to the response time
beware: leaving out doesn't prevent cache, browser just guesses
beware: origin web server is locked out until timer expires, no way of updating resource

can control cache revalidation:
  `no-store`: no cache
  `no-cache`: revalidate before using cache, i.e. misnomer, doesn't mean "no cache"
  `must-revalidate`: revalidate after expired, i.e. misnomer, doesn't mean "must revalidate"
beware: don't just reuse a smallish `Cache-Control`, can't invalidate cache if a resource changed earlier, website can even break if doesn't refetch interdependent resource to one that isn't cached (or was deleted from cache) ⚠️

can set fingerprint of resource in `ETag` (or last modified date in `Last-Modified`) header to revalidate expired cache resources before refetching
for CC `must-revalidate`, if cache is expired, browser requests resource with `If-None-Match` header with Etag value (or `If-Modified-Since` header with Last-Modified value), server sends only resource if has changed, otherwise sends `304 Not Modified` with empty body and new `Cache-Control` header until which browser reuses cache
beware: doesn't work with HTTP API since generates content from database, no file to compare to !!!!?!?!?!?!?!
I.E. four cases, cache hit, cache miss due to empty cache, cache miss + failed revalidation, cache miss + successful revalidation



can version URL of assets with hash and set max caching duration of one year `Cache-Control: max-age=31536000`
  version in build step or automatically by CDN
  change URL with new version and cache is untouched
beware: doesn't work with hypertext document since URL would change!!
for hypertext documents needs to revalidate each time, can set `Cache-Control: no-cache`
if not time critical can also cache hypertext document, but only if all dependencies are cached as well !!!! otherwise could break website using newer dependencies with old hypertext document !!!!

## Resources

[web.dev - Prevent unnecessary network requests with the HTTP Cache](https://web.dev/http-cache/)
[Jake Archibald - Caching best practices & max-age gotchas](https://jakearchibald.com/2016/caching-best-practices/)