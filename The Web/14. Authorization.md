# Authorization

[TOC]


<!-- ToDo: finish -->

## Introduction

- verification of permissions
- needs a permission scheme, e.g. admin, user, guest, etc.
- needs authentication already done
- beware: don't confuse with authentication, see Authentication ❗️


## HTTP authorization

- `403 Forbidden` response if authenticated correctly but not authorized ❗️
?!?! may read user from `Authorization` header or cookie


<!-- todo: integrate with Authentication -->

## Terminology

<!-- TODO: ADOPT OAUTH "CLIENT" AS TERMINOLOGY, MUCH BETTER THAN RESOURCE PROVIDER -->
- service provider (SP):
- identity provider (IP):
- resource provider (RP):
OAuth used for primarily authentication (and authorization since implied) often ?ALWAYS has SP = RP, e.g. Yelp, GitHub Login
OAuth used for primarily authorization (and authentication since implied) often ?ALWAYS has SP != RP, e.g. Yelp, GitHub Login, Google Contacts

can't have authentication / authorization separate, can't have one without the other, doesn't make sense
    how could authorize, if doesn't know identity, needs authentication
    what would authentication serve, if doesn't know permissions, wants also authorization
any login is always both authentication / authorization, including OAuth (+- OpenID Connect), can't separate
difference between OAuth and OAuth + OpenID Connect
- OAuth: used for authentication / authorization of SP (on behalf of user) to RP, i.e. RP != SP
- OAuth + OpenID Connect: used for authentication / authorization of user to SP, i.e. RP = SP
i.e. difference is who is authenticated / authorized to whom

## OAuth 2.0

<!-- todo: correct, both authentication and authorization -->
- standard for delegated authorization
granular, revokable permissions
not possible if gives credentials themselves

gets access token

misused for authentication
 e.g. IP creates session with client, single sign-on for multiple SPs
bad, because but no standardization for SP to get user information
-> OpenID Connect

LOGOUT
must differentiate between
- logout from SP: call /logout on SP to invalidate current session
- logout from IP: call /logout on IP
- logout from all SPs that use same IP: call /logoutAll on IP which calls /logout on all other SPs, pass along user info (`sub` claim in JWT)

access token can be stateful or stateless,
    if stateful, then RP needs  to IP, ask if still valid, requires network request, latency
        but can revoke
    if stateless, then RP can check signature, as long as isn't expired
        but can't revoke (because otherwise would need to ask IP if still valid for each request, is essentially stateful token)
OAuth doesn't mandate one or the other

only ACF allows(??) for refresh token, since other flows can't store securely (back channel only don't need refresh token, since not on behalf of user )
refresh token needed, when SP needs access to RP without client, e.g. clean up email at midnight
    SP takes refresh token to IP, gets new access token
    refresh token is very long lived (e.g. 1 year)
    beware: only use refresh token with Authorization code flow, otherwise stored on client, keys to castle!!!
otherwise when access token expires and client accesses RP, RP (?OR SP) can just redirect through auth flow again, IP gives new access token, just redirects if client has still session with IP
I.E. REFRESH TOKENS NOT NEEDED IF USES OAUTH FOR AUTHENTICATION SINCE RP = SP, rely on session of IP with client, IP must figure out how to make it long-lived and still secure, basically shifts the problem to the IP
refresh tokens need to be revoked as well if access token is revoked
get new refresh token as well with every access token, this way notices when refresh token is stolen if using refresh token returns error
    -> make access token short lived, automatically block account when refresh token is detected to be compromised

access token lifetime ca. 10-15 mins

access token is not intended to be read (understand) by client, opaque, only by RP (and IP who issued it)

session token = reference token
    pointer to metadata kept by client
"token" token = self-contained token

access token can be reference token or self-contained token
(---> SEE! HOW I GUESS IN 13.1 MAN. AUTH.MD)
-##### REFERENCE TOKEN
client must send access token to RP since [?], same process like you guessed with session ID
called "Token introspection"

-##### SELF-CONTAINED TOKEN
client doesn't need to send to RP, can validate itself




### OpenID Connect

<!-- todo: correct, both authentication and authorization 

just defines standard to expose user info to SP (= RP)
-->
- extension of OAuth for authentication
same OAuth flows

just adds `openid` as scope
gets back access token AND id token
id token has user info (format is signed JWT)
also /userinfo endpoint on IP to get more user info with access token

also adds metadata / discovery document to IP, JSON
    contains documentation of endpoints
    contains URL of RP (set by dev of SP earlier?!), that SP then reads out, and sends its received access token to

?? mandates JWT for other tokens as well ??

### ??

Website with backend: ACF
    website uses session cookie on client, keeps access token on backend in state
Website without backend: implicit flow
Native app: ACF with PKCE
    ?? has no backend ??, stores access token on client ?? SAME LIKE IMPLICIT FLOW
Microservices / API: client credentials flow

/// OAUTH

was intended for authorization of third party
later "abused" for social logins
-> build OpenID Connect as standard

recommended to use Authorization code flow, because access token stays away from client


### Authorization code flow
if has back-channel
(back + front channel)

SP redirects client to IP (with callback, response type "code", scope, client ID), client login to IP, IP redirects client back to SP (to callback) with "one-time code" ("authorization grant", authorization code) in query parameter of callback URL
SP takes one-time code + client secret to IP to get access token, SP accesses resource on resource server using access token
access token never leaves SP, access token stays on SP, not on client
    attacker can't use authorization code without client secret

"client ID": identifier for SP to IP
"client secret": secret key only known to IP and SP
beware: don't confuse "client" with actual client of SP, "client" here is client of IP which is SP itself
"client" is the service itself and not the browser. In his example, the "client" is the back-end server of Yelp and not the website of Yelp that's open in your browser!
beware: terminology is confusing

IP requires beforehand setup of SP, store client secret, legal callback URLs (to avoid phishing)

### Implicit flow
if has no back-channel, purely client-side app which directly calls APIs
(front channel only)

same as ACF, but IP gives client directly access token instead of one-time code
since there is no backchannel
access token in URL fragment instead of URL query, not send to server!!!

client is actually client on browser

problem: need to auth every 15 mins
-> non-uniform opinions about you to solve that

beware: never use implicit flow with back-end, ship access code to back-end, instead use authorization code flow!!!

### Resource owner password credentials flow
(back channel only)

???

### Client credentials flow
(back channel only)

???
SP trades client credentials (client ID + client secret) against token with IP, SP uses token to access RP
direct access, no user involved, machine-to-machine, no delegation

## Resources

- [Nate Barbettini - OAuth 2.0 and OpenID Connect (in plain English)](https://www.youtube.com/watch?v=996OiexHze0)
- [Nate Barbettini - OAuth 2.0 <debugger/>](https://oauthdebugger.com)
- [Nate Barbettini - OpenID Connect <debugger/>](https://oidcdebugger.com)