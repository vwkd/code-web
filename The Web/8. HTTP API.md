# HTTP API

[TOC]

<!-- ToDo: finish -->


## Introduction

- API for operations on resources on the Internet, e.g. CRUD (Create, Read, Update, Delete)
- request specifies resource and operation
- response gives result
- request / response body is usually in JSON
- beware: don't confuse with Web Server that serves Web pages ❗️



## Representational State Transfer (REST)

- architectural style of HTTP APIs
- API is called "RESTful API"
- uses URL to define unique resource
- uses HTTP methods to define operations, e.g. GET, POST, PUT, DELETE for CRUD (Create, Read, Update, Delete)
- has same URL for different operations on same resource, e.g. GET / POST / PUT / DELETE request to `/user/[id]`, etc.
- earlier styles used URL to define unique action on unique resource, because only GET and POST HTTP methods existed
- earlier styles had multiple URLs for different actions on same resource, e.g. GET to `/getUser`, POST to `/createUser`, etc.

  - rigid, because response from URL is not determined by request
data in response is independent of request

returns restricted amount of data per URL
uses multiple URLs for multiple resources

request can not specify exactly what data it needs
each single URL sends too much data while doesn’t include all data needed
for nested data has n+1 round trips

would need to encode in URL, becomes too complicated, so only finite set of possible options is allowed

- disadvantages:
  - high bandwith or high latency, because transmits more data than needs or needs follow-up request for nested data
  - difficult analytics, because doesn't know exactly what data consumers use
  - dependent, because design is dependent on what data consumer selects
  - difficult versioning, because can't extend same URL without breaking existing consumers
- advantages:
  - easy caching, because data is separated by URL
  - simple, because no additional query processing on server



## GraphQL

- API query language, JSON-like
- used for new architectural style of HTTP APIs
- API is called "GraphQL API"
- beware: don't confuse query language with architectural style ❗️
- beware: don't confuse with graph database, query language has no dependencies on underlying database ⚠️
- uses query to define unique action on unique resource
- uses single URL and HTTP method to transmit a query in the request body, e.g. POST to `/api/v1/`

can create infinitely many virtual endpoints, any combination, fine API
  consumer can request exactly data that needs in single request
rest can not create endpoint for every resource, and any combination of them, coarse API
  therefore needs to use small set, needs multiple requests to get desired subset of data

RESOURCE AND ACTION AREN'T BUNDLED TO HTTP SERVER, HTTP SERVER JUST TRANSPORTS DATA

data in response is dependent on request

SHIFTS OFFER/SELECTION OF RESOURCES AND ACTIONS TO OWN LAYER, INSTEAD OF INTO TRANSPORT (??) LAYER (URL, METHOD)
UNTIES RESOURCES AND ACTIONS FROM TRANSPORT LAYER

possible resources and actions can be infinitely more fine grained because don't need different URL

returns variable data, depending on GraphQL query
single URL, since data is variable, doesn't use different HTTP verbs, HTTP verb is POST
request can specify exactly what data it needs, not more not less, even nested data to eliminate n+1 round trips
N+1 PROBLEM

has a schema and static types

additional processing on server, 

SHIFTS ASSEMBLY OF PERSONALISED DATA TO SERVER INSTEAD OF ASSEMBLING ON CLIENT

CONSUMER SPECIFIES WHAT WANTS IN FINE QUERY INSTEAD OF COARSE ENDPOINT


URL doesn't identify resource !!!

CONSUMER SPECIFIES WHAT WANTS



- advantages:
  - low bandwith and low latency, because transmits just data that needs without need for follow-up request for nested data
  - easy analytics, because knows exactly what data consumers use
  - independent, because design is independent from what data consumer selects
  - easy versioning, because can extend same URL without breaking existing consumers
- disadvantages:
  - difficult caching, because data is not separated by URL
  - complex, because additional query processing on server


## Design Principles

- simple, selfexplanatory naming
- independent of implementation, e.g. database 
- independent of consum, e.g. mobile app
- model the data, not the view
- implement what you need, not what you think you will need
- "When in doubt leave it out!"
- evolve, don't rewrite



## Resources

- [REST API Tutorial - What is REST](https://restfulapi.net/)
- [How To Design A Good API and Why it Matters](https://www.youtube.com/watch?v=heh4OeB9A-c)