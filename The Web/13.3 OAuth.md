# OAuth 2.1

[TOC]


<!-- ToDo: finish -->

## Introduction

- standard for access delegation
- actually a collection of standards
- beware: not only for one or the other auth, can't separate ❗️
- beware: two distinct use cases aren't split on authentication vs. authorization, but getting access to identity vs. (non-identity) resource ⚠️
- describes how to get access token (deputy credentials)
- beware: doesn't describe what to do with it, e.g. storage



## Terminology

### Resource owner

- owner of the protected resource

### Resource server

- service that provides the protected resource of user, should have been called resource provider (RP), e.g. API
- beware: don't build own auth logic, use existing vetted libraries, e.g. ??, AppAuth, etc. ❗️

### Authorization server

- service that provides identity and permissions of RO, should have been called auth provider (AP)
- beware: can have AS = RS, but shouldn't couple tightly for security and scaling, see Cloud#Microservices ❗️
- beware: don't build own AS, use existing vetted providers, e.g. Okta, Auth0, FusionAuth, Google Identity Platform, Amazon Cognito, etc. ❗️

### Client

- service that wants access to resource on behalf of user, should have been called service provider (SP)
- beware: client is not necessarily a "front-end client", can be back-end or front-end ⚠️
- beware: doesn't specify "front-end client" in UA when client is back-end only, usually from same provider as client but not necessarily ⚠️
- beware: doesn't specify how client that's back-end only keeps state with "front-end client" if "front-end client" is from same provider, e.g. typical session cookie ❗️
<!-- 
Client accesses resource on behalf of RO
But Client = RO possible, then machine-to-machine
 -->
- public client: client that can't keep secret, therefore doesn't have a client secret, therefore its identity isn't confirmed, e.g. client is front-end (e.g. SPA without back-end, native app, etc.)
- confidential client: client that can keep secret, therefore does have a client secret, therefore its identity is confirmed, e.g. client is back-end (e.g. SPA with back-end, etc.)
- first-party client: client from same provider as RS (& AS)
- third-party client: client from different provider as RS (& AS)
- beware: don't build own auth logic, use existing vetted libraries, e.g. ??, AppAuth, etc. ❗️
- beware: client can itself be the RO, machine-to-machine communication, e.g. client of weather API ❗️

### Front- and Back Channel

- front channel: redirect requests through browser, visible in address bar, XSS-attackable
- back channel: direct requests, not in browser, not visible in address bar, not XSS-attackable
- beware: mean user-facing part of browser, for client that is "front-end client" back channel is Fetch API ❗️



## Motivation

- give client access to RO's resource on RS, e.g. Yelp to Google Contacts
- expose RO's credentials only to AS, not to client, i.e. needs front channel

### Direct access

- client has credentials of RO
- client acts like RO

![direct access flow of data](static/authaccdir.svg)

- client sees credentials of RO
- client gets unlimited access, infinite duration, full permission
- RS must keep credentials
- disadvantages:
    - less secure, because can't limit access
    - doesn't scale, because each RS handles credentials itself
- advantages:
    - simple, because no layer of indirection

### Delegated access

- client has deputy credentials of RO
- client is separate from RO
- needs additional auth provider, layer of indirection

![delegated access flow of data](static/authaccdel.svg)

- client doesn't see credentials of RO
- client gets limited access, finite duration, granular permissions
- RS doesn't need to keep credentials
-> secure, scales
- advantages:
    - more secure, because can limit access
    - scales, because only AS handles credentials
- disadvantages:
    - complex, because additional layer of indirection



### Access token

- deputy credentials
- identifier for scope and lifetime of deputy credentials
- opaque to client, just transparent to AS and possibly RS
- short lifetime, such that client needs to auth with AS often
- rely on AS to keep long session with UA, shifts attacker focus on single session with AS instead of client(s) with RS
- can be revokable or not revokable
- no standardized format, for self-contained token choses usually signed JWT
- should use proof of possession to make stealing useless, e.g. Mutual TLS, DPOP, etc.
- beware: on public client can't store access token since JS-accessible storage is XSS-attackable, instead keep it in memory ⚠️
- beware: AS should never issue same access token twice ❗️

<!-- ToDo: make general, because also applies to ID token -->

beware: can use JWT for maximum flexibility, can treat as reference token with introspection endpoint, or as self-contained token with verification using public key

#### Reference token
<!-- todo: (session token in 13.1) -->

- stateful, identifier for metadata on AS
- RS must validate access token with AS for each request, see Token introspection
- opaque to RS
- advantages:
    - revokable, because AS can inform RS about rejection
- disadvantages:
    - high latency, because RS needs one roundtrip to AS for each request
    - high storage, because AS needs to store
- beware: RS can use short cache if accepts that can't immediately reject revoked tokens to combat high latency ❗️
- use for small-scale RS, or when AS = RS

##### Token introspection

<!-- todo: add that can also use for self-contained tokens
for example can only use for sensitive scopes, let unimportant scopes unchecked through (as long as valid signature), i.e. can still use even if revoked
 -->

<!-- ?? verification of token by recipient -->
- validation of access token by AS
- RS sends access token to AS
- gets back document with data (e.g. validity, expiry time, etc.), usually in JSON
- beware: RS can use short cache if accepts that can't immediately reject revoked tokens to combat high latency ❗️
RS should use authentication to AS, needs RS credentials

#### Self-contained token
<!-- todo: (auth token in 13.1) -->

- stateless, metadata itself
- signed and expiry time
- RS can validate access token itself, check expiry time and signature, no need for token introspection
- transparent to RS
- beware: still opaque to client, don't rely on information in it, e.g. email in `sub` of JWT from Okta might very well change ⚠️
- advantages:
    - low latency, because RS doesn't need roundtrip to AS
    - low storage, because AS doesn't need to store
- disadvantages:
    - not revokable, because AS can't inform RS about rejection
- beware: if makes self-contained token revokable, needs to reintroduce state on AS, however less load on AS than with reference token, since can filter out invalid tokens already on RS by checking signature and expiry time, makes roundtrip only for valid or revoked tokens ❗️
- use for large-scale RS, or when AS ! = RS



## Access token flow

- ways to get access token
- beware: consider making public client a confidential client by creating a back-end even if it's just for OAuth, separates auth logic away, access token flow is safe from XSS attacks, can use refresh tokens, etc., e.g. can use serverless functions, etc. ⚠️

### Authorization code flow with PKCE

- RO is user
- for public and confidential clients
- front channel transmits only authorization code, back channel transmits access token
- steps:
    - (client fails to access resource on RS because of invalid / missing access token)
    - client generates new random secret for the current flow, store secret temporarily, e.g. session storage, session cookie, etc.
    - client redirects UA to AS (oauth URL) with hash of secret, client ID, response type, scope, callback URL in query parameter of URL, AS saves hash of secret temporarily
    - UA logs into AS, accepts permission prompt (if not previously done)
    - AS redirects UA back to client (callback URL), authorization code in query parameter of URL
    - client sends authorization code along with plaintext secret and client ID to AS, usually in body of POST request, AS verifies that hash of plaintext secret is same as hash from earlier
    - AS returns access token, usually in JSON
    - client sends access token to RS, usually in `Authorization: Bearer <token>` header
    - RS returns resource
- client can also send state parameter to AS, just echoed back by AS
- can use state to remember destination URL

<!-- todo: update to PKCE -->
![OAuth authorization code flow](static/oauthacf.svg)

- authorization code is single-use, short lived, e.g. 1 min
- authorization code is useless without plaintext secret
- advantages:
    - secure, because UA can't get access token without knowing plaintext secret
- disadvantages:
    - needs back-end, because needs to store access token
    - needs browser, because relies on redirects to AS and back
- PKCE verifies integrity of flow, otherwise authorization code injection attack where swaps authorization codes from two distinct flows, attacker can log in as user or user can be logged in as attacker, see [OAuth Happy Hour - Authorization Code Injection Demo](https://youtu.be/moQidjdV5cw?t=562)
- PKCE protects against state-changing CSRF requests, since client can't complete flow it didn't initialise because plaintext secret is missing, i.e. replaces state value
- beware: public client with PKCE is still XSS-attackable, e.g. could still make authorization code injection attack by stealing PKCE secret alongside authorization code, since PKCE secret must be stored in JS-accessible storage, or could plant PKCE secret for state-changing CSRF request ⚠️
- confidential client can send additional client secret when requesting access token to AS, prevents any client from doing request

<!-- Public clients have no secret
Registered at AS only for ?? Associating client ID with callback URL
But could just as well use callback URL as identifier, wouldn’t need to register
-> IndieAuth
https://indieauth.net

client secret not really needed, except to limit authentic clients from making access request as that client to AS
-> not needed actually, because callback URL is already pinned at AS, so wouldn’t get redirected back to attacker anyways
-> IndieAuth takes one step further, allows to provide own AS which specifies has itself a fixed callback URL ?!?! But then couldn’t use with multiple clients -->

- beware: client secret doesn't replace PKCE secret, since doesn't verify integrity of flow itself ❗️
- beware: client needs to register beforehand with AS, i.e. client ID, client secret (if public client), allowed callback URL(s), etc.

### Client credentials flow

- RO is client itself
- for confidential clients only
- beware: for public clients there is no solution, could just as well make RS open to everyone ⚠️
- back channel transmits access token
- steps:
    - (client fails to access resource on RS because of invalid / missing access token)
    - client sends client ID and client secret to AS, usually in body of POST request
    - AS returns access token, usually in JSON
    - client sends access token to RS, usually in `Authorization: Bearer <token>` header
    - RS returns resource

![OAuth credentials flow](static/oauthcf.svg)

### Device code flow

<!-- todo: finish -->



## Refresh token

should only use on confidential clients!
    although might use on public client with rotation, e.g. mobile apps, in browser-based apps can just do flow because redirect happens so fast 
in CCF usually not used, but might make sense if has multiple instances of client, and wants to revoke only ATs for a specific instance, then can just revoke ATs connected to that RT

should require presenting client secret OR rotation

AS needs to keep track which ATs where obtained by a given RT
to be able to revoke all ATs when RT is detected as compromised

in ACF need to request own scope
returns refresh token alongside access token
- if no refresh token, then client repeats flow when access token is invalid, relies on AS to keep long-lived yet secure session with UA
- if has refresh token, then client repeats flow when refresh token is invalid, when access token is invalid uses refresh token to obtain new one, see Refresh token
when refresh token turns out to be invalid, then start new flow again
    client doesn't need to know expiration time because doesn't matter, always new flow

- like a reusable authorization code
- client sends to AS (along with client ID and client secret), gets new access token and possibly new refresh token
- allows client to get new access token without RO and repeating whole flow
- needs when client operates without RO present, e.g. clean up contacts at midnight
- beware: see IF
- opaque to client, just transparent to AS
- long lifetime, such that client doesn't need to do flow often
- beware: don't use with public client since can't store securely, don't use with CCF since can just as well use regular flow ⚠️
    beware: on public client can't store refresh token since JS-accessible storage is XSS-attackable, instead keep it in memory, i.e. can silent renew only until page reload / page close ⚠️

- beware: AS needs to revoke refresh token when access token is revoked ❗️
- refresh token should either be rotated or sender-constrained
    - rotated: AS issues new refresh token with every new access token, stores old refresh tokens, when sees old refresh token being used knows that client was breached (either attacker has old one because client has recent one, or other way around), if breached revokes all access and refresh tokens
    - sender-contrained: client needs to provide proof of possession to AS, e.g. client secret, mutual TLS, etc.
- beware: AS usually requires additional scope to request refresh token, e.g. `offline_access`

- beware: can't use on public client, since would store insecurely
COULD IF ONE-TIME USE, but still risky, valid until user uses app next time



## Logout

<!-- todo: ??? -->
<!-- difference between self-contained token and reference token ?!?! -->

depends on UX
logout of AS logs out everywhere
logout of single client, comes back, magically logged in because automatically redirected to AS and back -> No point in logout...

must differentiate between
- logout from client: call /logout on client to invalidate current session
- logout from AS: call /logout on AS
- logout from all SPs that use same AS: call /logoutAll on AS which calls /logout on all other SPs, pass along user info (`sub` claim in JWT)

revocation may invalidate consent as well, depends on AS



## OpenID Connect

<!-- identification NOT AUTHENTICATION
reading out identity as client
AS has verified identity already (authentication )

access of client to RS (resource) vs. access of client to AS (identity)

may want one or other or both
if resource, then OAuth scopes, use access token, no id token
if identity, then only OpenID Connect scopes, use id token, ignore access token
if both, then both scopes, use both tokens
 -->

audience of access token is resource server, not client, client just uses opaquely
audience of id token is client, not resource server, client doesn't send to resource server

<!-- todo: ?? use case: access third-party resource, access first-party resource 
first-party client ??
-->
- extension of OAuth 2.0
- standard for delegated access to identity of RO
<!-- todo: reconsider term "Sign-On" and definition of "Single Sign-On" -->
- Sign-On: special case where RS = AS and resource is RO's identity
allows client to offload identity management to AS, no need to keep user credentials itself, user only needs to have account with AS, ready to go
 
- beware: can use purely on top of OAuth, i.e. like having two RSs
- beware: client doesn't need to use user info for Single Sign-On, e.g. can use to mandate authentication strength (recent authentication date, strong authentication method), etc.
- Single Sign-On: Sign-On with multiple clients for same AS, e.g. Google, Apple, etc.
    Single Sign-On, when RO uses same AS for multiple clients ???? IS THAT REALLY SSO?
    after first client needs to only grant access, login already from session with AS


beware: if client allows multiple AS for login, gets different `sub` for different ASs, needs to deduplicate, e.g. sending email asking if wants to merge accounts, or in client ask to link any other ASs etc.


OAuth also good for access of first-party clients, separates concerns, concentrates login to single point,
beware: treat first-party clients like third-party clients
only place where RO ever enters credentials
can focus security on single point
separate concerns
single place that can evolve quickly, e.g. add 2FA
needs to secure credential input into client , doesn't scale
doesn't scale with extending security
best example is Google


### Userinfo endpoint

- user info endpoint on authorization server, contains user info
- client can read user info using access token
- format is usually JSON

### Identity token

- self-contained token for user info
- beware: not revokable, see Self-contained token
- format is signed JWT
- ??? beware: doesn't mandate format for other tokens ❗️
- beware: client must not identify user from claims that can change, e.g. Apple apps identifying user from `email` claim, see [Aaron Parecki - The Real Cause of the Sign In with Apple Zero-Day](https://aaronparecki.com/2020/05/31/30/the-real-cause-of-the-sign-in-with-apple-zero-day) ❗️

beware: only rely on `sub` claim as user ID, email etc. may change

### ACF

- adds more scopes, some registered, rest custom, e.g. `openid`, `profile`, `email`, etc.
beware: polutes OAuth since reuses same scope that access to resource server uses, could use alongside access to RS , mixes things up
-> should have been GraphQL query instead
- gets back identity token alongside access token
infos depend on scopes, `openid` usually only `sub`, `profile` gives name, `email` gives email, etc.
can hit /userinfo with access token for full info ?? GETS FULL USER INFO OR ONLY WHAT SCOPES REQUESTED?

for login just ignores access token (if doesn't request more from /userinfo endpoint)
- beware: signed JWT doesn't make sense, could just as well be JSON ⚠️
gets JSON from userinfo endpoint, unneccessary second request, should have returned alread here directly



## Future Work

- AS shouldn't need to know which clients RO access
- client shouldn't by default be able to get whole RO identity from AS, only relevant details allowed by RO, e.g. only age, but not address, or even only boolean if age larger than X,  etc.
- private key on device



## Implementation

RS & AS are under the same hood, synchronize scopes & introspection endpoint / public key
    often AS is provided by same company as RS, e.g. Google, GitHub
    but not necessarily, e.g. Okta, Auth0, etc.
developer builds either client, or RS (with AS)

### Client

- get AT from AS with right scopes
- make request to RS
- handle successful / failure request to AS as well as to RS 

### RS

- check for valid access token
- check for right scopes for operation
    e.g. read, write, etc.
- do operation, return result

API
middleware
    - has auth header? no -> 401
    - extract token from auth header (split at " ", discard first part)
    - verify token (using auth library, needs to initialise first, also set up `.env` with secrets, e.g. `const { claims } = await oktaJwtVerifier.verifyAccessToken(token, process.env.OKTA_AUDIENCE)`) -> does all the heavy lifting like token introspection ?!?!
    - has claims? no -> 401
    - has correct claims for operation? no -> 401

RS doesn't mind flow it's going to be used, can be CCF, but also ACF
BUT NEEDS TO USE SECRETS OF WHO? OF CLIENT?!?!

### AS

- offer login to RO, show scopes, MFA, etc.
- keep session with RO, session cookie, PKCE hash, etc.
- return authorization code
- verify authorization code against client data and PKCE hash
- return access token



AS creates session with RO 
leave to AS how to make that session last long while being secure


if same AS is used for multiple RS needs to use Resource Indicators, e.g. Google for Google Contacts and YouTube




shows concent screen to RO
beware: public ASs should show detailed consent screen, e.g. otherwise phishing client could impersonate legitimate client, e.g. [New Google Docs phishing scam](https://www.reddit.com/r/google/comments/692cr4/new_google_docs_phishing_scam_almost_undetectable/)
Google doesn't show callback URL
see GitHub shows callback URL
    block misleading names, e.g. of own clients
    show AS name (own), e.g. Google
    show RO name, e.g. My Private Account
    list scopes, without overwhelm, possibly allow to edit
    show client name, redirect URL, more client information from registry with AS

needs to store authorization code tied to RO

- offer client registration, associate client id with callback URL(s), etc.
- offer client unregistration, revoke all access tokens (and refresh tokens)
- token lifetime, may decide based on different user groups (admin shorter), etc.
- do login, 2fa, etc
- permission prompt
- allow user to revoke clients, revokes all access (and refresh) tokens
- scopes, synchronised with RS
- endpoints for token, id, refresh, etc.
- keep session
- don't give token if callback URL doesn't match
- rotate keys
- invalidate access tokens when authorization code is redeemed twice
- if self-contained access token and/or id token use correct claims, e.g. unique `sub` claim in id token, etc.
- access token expiry time, refresh token expiry time
- how to handle refresh tokens, e.g. online access only, then revoke refresh token when UA session with AP expires / logout, etc.
- refresh token rotation, revoke when old one is used, beware: don't revoke when one in another instance is used
- invalidate consents after user didn't use client for long time 
- etc.

- may publish discovery document, clients can get info dynamically, e.g. endpoint URLs, public keys, etc.





## Resources

- [Nate Barbettini - OAuth 2.0 and OpenID Connect (in plain English)](https://www.youtube.com/watch?v=996OiexHze0)
- [Nate Barbettini - OAuth 2.0 <debugger/>](https://oauthdebugger.com)
- [Nate Barbettini - OpenID Connect <debugger/>](https://oidcdebugger.com)
- [Aaron Parecki - Securing Your APIs with OAuth 2.0](https://www.youtube.com/watch?v=PfvSD6MmEmQ)
- [Aaron Parecki - How OAuth Works](https://www.youtube.com/playlist?list=PLRyLn6THA5wN05b3qJ6N0OpL3YbritKI-)
- [Aaron Parecki - OAuth 2.0 Simplified](https://www.oauth.com)
- [Philippe De Ryck - Introduction to OAuth 2.0 and OpenID Connect](https://www.youtube.com/watch?v=GyCL8AJUhww)