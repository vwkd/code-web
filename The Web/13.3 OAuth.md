# OAuth 2.1

[TOC]


<!-- ToDo: finish -->
<!-- todo: improve header -->

## Introduction

- standard for access delegation
- actually a collection of standards
- beware: not only for one or the other auth, can't separate ❗️
- beware: two distinct use cases aren't split on authentication vs. authorization, but getting access to identity vs. resource (non-identity) ⚠️
- describes how to get access token (deputy credentials)
- beware: doesn't describe what to do with it, e.g. storage

## Terminology

### Resource owner

- owner of the protected resource

### Resource server

- service that provides the protected resource of user, should have been called resource provider (RP), e.g. API
- beware: don't build own auth logic, use existing vetted libraries, e.g. ??, AppAuth, etc. ❗️

### Authorization server

- service that provides authentication and authorization of resource owner, holds identity and permissions of RO, should have been called auth provider (AP)
- beware: can have AS = RS, but shouldn't couple tightly for security and scaling, see Cloud#Microservices ❗️
- beware: don't build own AS, use existing vetted providers, e.g. Okta, Auth0, FusionAuth, Google Identity Platform, Amazon Cognito, etc. ❗️

### Client

- service that wants access to resource on behalf of user, should have been called service provider (SP)
- beware: client is not necessarily a "front-end client", can be back-end or front-end ⚠️
- beware: doesn't specify "front-end client" in UA when client is back-end only, usually from same provider as client but not necessarily ⚠️
- beware: doesn't specify how client that's back-end only keeps state with "front-end client" if "front-end client" is from same provider, e.g. typical session cookie ❗️
- public client: client that can't keep secret, therefore doesn't have a client secret, therefore its identity isn't confirmed, e.g. client is front-end (e.g. SPA without back-end, native app, etc.)
- confidential client: client that can keep secret, therefore does have a client secret, therefore its identity is confirmed, e.g. client is back-end (e.g. SPA with back-end, etc.)
- first-party client: client from same provider as RS (& AS)
- third-party client: client from different provider as RS (& AS)
- beware: don't build own auth logic, use existing vetted libraries, e.g. ??, AppAuth, etc. ❗️
- beware: client can itself be the RO, machine-to-machine communication, e.g. client of weather API ❗️

### Front- and Back-Channel

- front-channel: requests that pass through (user-facing part of) UA, i.e. not observable by user, not attackable by JavaScript, etc.
- back-channel: requests that don't pass through (user-facing part of) UA, i.e. not observable by user, not attackable by JavaScript, etc.
- beware: if client is "front-end client" on UA itself, then back-channel is `fetch` while front-channel is address bar ❗️



## Motivation

- give client access to RO's resource on RS, e.g. Yelp to Google Contacts
- expose RO's credentials only to AS, not to client, i.e. needs front-channel

### Direct access

- client has credentials of RO
- client acts like RO

![direct access flow of data](static/authaccdir.svg)

- client sees credentials of RO
- client gets unlimited access, infinite duration, full permission
- RS must keep credentials
-> insecure, doesn't scale

### Delegated access

- client has deputy credentials of RO
- client is separate from RO
- needs additional auth provider, layer of indirection

![delegated access flow of data](static/authaccdel.svg)

- client doesn't see credentials of RO
- client gets limited access, finite duration, granular permissions
- RS doesn't need to keep credentials
-> secure, scales



## Authorization server

<!-- todo -->

AS creates session with RO 
leave to AS how to make that session last long while being secure

Single Sign-On, when RO uses same AS for multiple clients
after first client needs to only grant access, login already from session with AS

often AS is provided by same company as RS, e.g. Google, GitHub
but not necessarily, e.g. Okta, Auth0, etc.

if same AS is used for multiple RS needs to use Resource Indicators, e.g. Google for Google Contacts and YouTube

OAuth also good for access of first-party clients, separates concerns, concentrates login to single point,
beware: treat first-party clients like third-party clients
only place where RO ever enters credentials
can focus security on single point
separate concerns
single place that can evolve quickly, e.g. add 2FA
needs to secure credential input into client , doesn't scale
doesn't scale with extending security
best example is Google

shows concent screen to RO
beware: public ASs should show detailed consent screen, e.g. otherwise phishing client could impersonate legitimate client, e.g. [New Google Docs phishing scam](https://www.reddit.com/r/google/comments/692cr4/new_google_docs_phishing_scam_almost_undetectable/)
Google doesn't show callback URL
see GitHub shows callback URL
    block misleading names, e.g. of own clients
    show AS name (own), e.g. Google
    show RO name, e.g. My Private Account
    list scopes, without overwhelm, possibly allow to edit
    show client name, redirect URL, more client information from registry with AS

needs to store authorization code tied to RO

- offer client registration, associate client id with callback URL(s), etc.
- offer client unregistration, revoke all access tokens (and refresh tokens)
- do login, 2fa, etc
- permission prompt
- allow user to revoke clients, revokes all access (and refresh) tokens
- scopes from RS
- endpoints for token, id, refresh, etc.
- keep session
- don't give token if callback URL doesn't match
- rotate keys
- invalidate access tokens when authorization code is redeemed twice
- if self-contained access token and/or id token use correct claims, e.g. unique `sub` claim in id token, etc.
- access token expiry time, refresh token expiry time
- how to handle refresh tokens, e.g. online access only, then revoke refresh token when UA session with AP expires / logout, etc.
- etc.




### Access token

- deputy credentials
- identifier for scope and lifetime of deputy credentials
- opaque to client, just transparent to AS and possibly RS
- short lifetime such that client needs to re-auth with AS frequently, e.g. 10-15 min
- rely on AS to keep long session with UA, shifts attacker focus on single session with AS instead of client(s) with RS
- can be revokable or not revokable
- no standardized format, for self-contained token choses usually signed JWT
- should use proof of possession to make stealing useless, e.g. Mutual TLS, DPOP, etc.
- beware: don't store access token on public client, e.g. Web Storage ⚠️
- beware: AS should never issue same access token twice ❗️

#### Reference token
<!-- todo: (session token in 13.1) -->

- stateful, identifier for metadata on AS
- RS must validate access token with AS for each request, see Token introspection
- opaque to RS
- advantages:
    - revokable, because AS can inform RS about rejection
- disadvantages:
    - high latency, because RS needs one roundtrip to AS for each request
    - high storage, because AS needs to store
- beware: RS can use short cache if accepts that can't immediately reject revoked tokens to combat high latency ❗️
- use for small-scale RS, or when AS = RS

##### Token introspection

- validation of access token by AS
- RS sends access token to AS
- gets back document with data (e.g. validity, expiry time, etc.), usually in JSON

#### Self-contained token
<!-- todo: (auth token in 13.1) -->

- stateless, metadata itself
- signed and expiry time
- RS can validate access token itself, check expiry time and signature, no need for token introspection
- transparent to RS
- beware: still opaque to client, don't rely on information in it, e.g. email in `sub` of JWT from Okta might very well change ⚠️
- advantages:
    - low latency, because RS doesn't need roundtrip to AS
    - low storage, because AS doesn't need to store
- disadvantages:
    - not revokable, because AS can't inform RS about rejection
- beware: if makes self-contained token revokable, needs to reintroduce state on AS, however less load on AS than with reference token, since can filter out invalid tokens already on RS by checking signature and expiry time, makes roundtrip only for valid or revoked tokens ❗️
- use for large-scale RS, or when AS ! = RS



## Access token flow

- ways to get access token
- beware: consider making public client a confidential client by creating a back-end even if it's just for OAuth, separates auth logic away, access token flow is safe from XSS attacks, can use refresh tokens, etc., e.g. can use serverless functions, etc. ⚠️

### Authorization code flow with PKCE

- RO is user
- for public and confidential clients
- front-channel transmits only authorization code, back-channel transmits access token
- steps:
    - (client fails to access resource on RS because of invalid / missing access token)
    - client generates new random secret for the current flow, store secret temporarily, e.g. session storage, session cookie, etc.
    - client redirects UA to AS (oauth URL) with hash of secret, client ID, response type, scope, callback URL in query parameter of URL, AS saves hash of secret temporarily
    - UA logs into AS, accepts permission prompt (if not previously done)
    - AS redirects UA back to client (callback URL), authorization code in query parameter of URL
    - client sends authorization code along with plaintext secret and client ID to AS, usually in body of POST request, AS verifies that hash of plaintext secret is same as hash from earlier
    - AS returns access token, usually in JSON
    - client sends access token to RS, usually in `Authorization: Bearer <token>` header
    - RS returns resource
- client can also send state parameter to AS, just echoed back by AS
- can use state to remember destination URL

<!-- todo: update to PKCE -->
![OAuth authorization code flow](static/oauthacf.svg)

- authorization code is single-use, short lived, e.g. 1 min
- authorization code is useless without plaintext secret
- advantages:
    - secure, because UA can't get access token without knowing plaintext secret
- disadvantages:
    - needs back-end, because needs to store access token
    - needs browser, because relies on redirects to AS and back
- PKCE verifies integrity of flow, otherwise authorization code injection attack where swaps authorization codes from two distinct flows, attacker can log in as user or user can be logged in as attacker, see [OAuth Happy Hour - Authorization Code Injection Demo](https://youtu.be/moQidjdV5cw?t=562)
- PKCE protects against state-changing CSRF requests, since client can't complete flow it didn't initialise because plaintext secret is missing, i.e. replaces state value
- beware: public client with PKCE is still XSS-attackable, e.g. could still make authorization code injection attack by stealing PKCE secret alongside authorization code, since PKCE secret must be stored in JS-accessible storage, or could plant PKCE secret for state-changing CSRF request ⚠️
- confidential client can send additional client secret when requesting access token to AS, prevents any client from doing request
- beware: client secret doesn't replace PKCE secret, since doesn't verify integrity of flow itself ❗️
- beware: client needs to register beforehand with AS, i.e. client ID, client secret (if public client), allowed callback URL(s), etc.

#### Refresh token

own scope
returns refresh token alongside access token
- if no refresh token, then client repeats flow when access token is invalid, relies on AS to keep long-lived yet secure session with UA
- if has refresh token, then client repeats flow when refresh token is invalid, when access token is invalid uses refresh token to obtain new one, see Refresh token


- like a reusable authorization code
- client sends to AS (along with client ID and client secret), gets new access token and possibly new refresh token
- allows client to get new access token without RO and repeating whole flow
- needs when client operates without RO present, e.g. clean up contacts at midnight
- beware: see IF
- opaque to client, just transparent to AS
- long lifetime, e.g. 1 year
- beware: don't use with public client since can't store securely, don't use with CCF since can just as well use regular flow ⚠️
- beware: AS needs to revoke refresh token when access token is revoked ❗️
- refresh token should either be rotated or sender-constrained
    - rotated: AS issues new refresh token with every new access token, stores old refresh tokens, when sees old refresh token being used knows that client was breached (either attacker has old one because client has recent one, or other way around), if breached revokes all access and refresh tokens
    - sender-contrained: client needs to provide proof of possession to AS, e.g. client secret, mutual TLS, etc.
- beware: AS usually requires additional scope to request refresh token, e.g. `offline_access`

- beware: can't use on public client, since would store insecurely
COULD IF ONE-TIME USE, but still risky, valid until user uses app next time

### Client credentials flow

- RO is client itself
- for confidential clients only
- beware: for public clients there is no solution, could just as well make RS open to everyone ⚠️
- back-channel transmits access token
- steps:
    - (client fails to access resource on RS because of invalid / missing access token)
    - client sends client ID and client secret to AS, usually in body of POST request
    - AS returns access token, usually in JSON
    - client sends access token to RS, usually in `Authorization: Bearer <token>` header
    - RS returns resource

![OAuth credentials flow](static/oauthcf.svg)

### Device code flow

???



## Logout

<!-- todo: ??? -->
<!-- difference between self-contained token and reference token ?!?! -->

depends on UX
logout of AS logs out everywhere
logout of single client, comes back, magically logged in because automatically redirected to AS and back -> No point in logout...

must differentiate between
- logout from client: call /logout on client to invalidate current session
- logout from AS: call /logout on AS
- logout from all SPs that use same AS: call /logoutAll on AS which calls /logout on all other SPs, pass along user info (`sub` claim in JWT)



## OpenID Connect

- extension of OAuth 2.0
- standard for delegated access to identity of RO
<!-- todo: reconsider term "Sign-On" and definition of "Single Sign-On" -->
- Sign-On: special case where RS = AS and resource is RO's identity
- beware: can use purely on top of OAuth, i.e. like having two RSs
- beware: client doesn't need to use user info for Single Sign-On, e.g. can use to mandate authentication strength (recent authentication date, strong authentication method), etc.
- Single Sign-On: Sign-On with multiple clients for same AS, e.g. Google, Apple, etc.

### Authorization server endpoints

- user info endpoint, contains user info
- client can read user info using access token
- discover document, contains OpenID Connect specification, e.g. 
- format is usually JSON

### Identity token

- self-contained token for user info
- beware: not revokable, see Self-contained token
- format is signed JWT
- ??? beware: doesn't mandate format for other tokens ❗️
- beware: client must not identify user from claims that can change, e.g. Apple apps identifying user from `email` claim, see [Aaron Parecki - The Real Cause of the Sign In with Apple Zero-Day](https://aaronparecki.com/2020/05/31/30/the-real-cause-of-the-sign-in-with-apple-zero-day) ❗️

### ACF

- adds `openid` as scope
- gets back identity token alongside access token
- beware: signed JWT doesn't make sense, could just as well be JSON ⚠️



## Resources

- [Nate Barbettini - OAuth 2.0 and OpenID Connect (in plain English)](https://www.youtube.com/watch?v=996OiexHze0)
- [Nate Barbettini - OAuth 2.0 <debugger/>](https://oauthdebugger.com)
- [Nate Barbettini - OpenID Connect <debugger/>](https://oidcdebugger.com)
- [Aaron Parecki - Securing Your APIs with OAuth 2.0](https://www.youtube.com/watch?v=PfvSD6MmEmQ)
- [Aaron Parecki - How OAuth Works](https://www.youtube.com/playlist?list=PLRyLn6THA5wN05b3qJ6N0OpL3YbritKI-)
- [Aaron Parecki - OAuth 2.0 Simplified](https://www.oauth.com)
- [Philippe De Ryck - Introduction to OAuth 2.0 and OpenID Connect](https://www.youtube.com/watch?v=GyCL8AJUhww)