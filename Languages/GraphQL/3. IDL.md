# IDL

[TOC]



## Introduction

- defines API, e.g. supported operations, fields, directives, etc.
- ??? uses type system
- ??? beware: don't confuse with query language, e.g. object fields and object field types
syntax of schema vs. syntax of request

??? checks if request is valid, e.g. query field that doesn't exist, type of variable, etc.



## Type System

??
- convention to write names lowerCamelCase (e.g. field, argument, etc.) and types UpperCamelCase

```plaintext
TypeSystemDefinition:
   SchemaDefinition TypeDefinition*+ DirectiveDefinition*+
```

- beware: differs from spec to allow multiple `TypeDefinition`s or `DirectiveDefinition`s in a `TypeSystemDefinition` instead of using multiple `TypeSystemDefinition`s in multiple `Definition`s, also only single `SchemaDefinition`, see [#788](https://github.com/graphql/graphql-spec/issues/788#issuecomment-721298885) ‚ùóÔ∏è

### Extension

- extension of type system, e.g. by local service
- can use to add new fields, interfaces, directives, etc.

```plaintext
TypeSystemExtension:
    SchemaExtension*+ TypeExtension*+

SchemaExtension: 
    "extend schema" Directives* { OperationTypeDefinition+ }
    "extend schema" Directives

TypeExtension:
    ScalarTypeExtension
    ObjectTypeExtension
    InterfaceTypeExtension
    UnionTypeExtension
    EnumTypeExtension
    InputObjectTypeExtension
```

- beware: differs from spec to allow multiple `SchemaExtension`s or `TypeExtension`s in a `TypeSystemExtension` instead of using multiple `TypeSystemExtension`s, see [#788](https://github.com/graphql/graphql-spec/issues/788#issuecomment-721298885) ‚ùóÔ∏è



## Schema

- definition of type system
- ??? uses types and directives

```plaintext
SchemaDefinition:
    Description* "schema" Directives* { OperationTypeDefinition+ }

OperationTypeDefinition
    OperationType : NamedType
```

- beware: in spec calls "root operation type", here leave out "root" since not needed ‚ùóÔ∏è
- operation type must be an Object type
- must define at least one query operation, other operations are optional
- different operation types must be different types, e.g. query operation type can't be same as mutation operation type
??? what about subscription, can have same type as query operation ???

```graphql
schema {
  query: MyQuery
  mutation: MyMutation
}

type MyQuery {
  myField: String
}

type MyMutation {
  setMyField(to: String): String
}
```

- shorthand: for schema with at most one `OperationTypeDefinition` for each `OperationType` and names of operation types identical to name of operation, can leave out schema

```graphql
# `schema { query: Query }` implicitly defined

type Query {
  myField: String
}
```

- beware: shorthand allows only at most one operation of each kind ‚ùóÔ∏è
- beware: shorthand silently ignores other types, e.g. due to misspelling ‚ùóÔ∏è

```graphql
# `schema { query: Query }` implicitly defined

type Query {
  myField: String
}

# Silently ignored, since doesn't match "Mutation" (or "Subscription")
type Mutaion {
  setMyField(to: String!): String
}
```

- beware: shorthand disallows use name "Query", "Mutation" or "Subscription" for other type than operation type, although shouldn't do that anyways to avoid confusion ‚ùóÔ∏è

```graphql
# `schema { query: Query, subscription: Subscription }` implicitly defined

type Query {
  myField: Subscription
}

# Becomes operation type unintendedly
type Subscription {
  nyField: String
}
```

- beware: don't use shorthand, define schema explicitly ‚ùóÔ∏è



## Output Type

- type of field, specifies values in response
- similar to TypeScript, e.g. object types, interface types, union types, etc.
- can use in type system where references `NamedType`
- name of type, field, argument must be unique, must not start with two underscores since reserved for introspection
- fields of primitive type are leaves in response tree, fields of composite type are intermediate nodes

### Named types

??

```plaintext
TypeDefinition:
    ScalarTypeDefinition
    ObjectTypeDefinition
    InterfaceTypeDefinition
    UnionTypeDefinition
    EnumTypeDefinition
    InputObjectTypeDefinition
```

- named type is nullable (includes `null` value) and singular, can use wrapping type to make non-nullable and/or list
- beware: for input type: `null` value and omission both describe lack of value, but separate things ‚ùóÔ∏è
- beware: doesn't use `type` keyword except for Object type even though are all types ‚ö†Ô∏è

#### Primitive types

- scalar

```plaintext
ScalarTypeDefinition:
    Description* "scalar" Name Directives*
```

- built-in scalars in any schema engine: `Int`, `Float`, `String`, `Boolean`, `ID`
- enum

```plaintext
EnumTypeDefinition:
    Description* "enum" Name Directives* EnumValuesDefinition*

EnumValuesDefinition:
    { EnumValueDefinition+ }

EnumValueDefinition:
    Description* EnumValue Directives*
```

#### Composite types

- object

```plaintext
ObjectTypeDefinition:
    Description* "type" Name ImplementsInterfaces* Directives* FieldsDefinition*

ImplementsInterfaces:
    ImplementsInterfaces & NamedType
    "implements" &* NamedType

FieldsDefinition:
    { FieldDefinition+ }

FieldDefinition:
    Description* Name ArgumentsDefinition* : Type Directives*

ArgumentsDefinition:
    ( InputValueDefinition+ )

InputValueDefinition:
    Description* Name : Type DefaultValue* Directives*
```

- `NamedType` in `ImplementsInterfaces` must be name of an interface, see Abstract types
- `Type` in `InputValueDefinition` must be an input type, see Input Type


#### Abstract types

- interface

```plaintext
InterfaceTypeDefinition:
    Description* "interface" Name ImplementsInterfaces* Directives* FieldsDefinition*
```

- Object type that implements interface must implement all its fields
- interface can't implement other interface that creates a cyclic reference, e.g. itself
- can use interface as type for field, field can return any Object type that implements that interface
- beware: if uses an interface as type for field, can only query fields that are on interface, i.e. guaranteed to be implemented by return type, or use fragment with type condition ‚ùóÔ∏è

```graphql
# part of schema
interface NamedEntity {
  name: String
}

type Person implements NamedEntity {
  name: String
  age: Int
}

type Contact {
  entity: NamedEntity
  phoneNumber: String
  address: String
}
```

```graphql
# operation
{
  entity {
    name
  }
  phoneNumber
}
```

```graphql
{
  entity {
    name
    ... on Person {
      age
    }
  },
  phoneNumber
}
```

- union

```plaintext
UnionTypeDefinition:
    Description* "union" Name Directives* UnionMemberTypes*
UnionMemberTypes:
    UnionMemberTypes | NamedType
    = |* NamedType
```

- beware: `NamedType` must be an Object type, currently doesn't allow union of primitive types, see [#215](https://github.com/graphql/graphql-spec/issues/215) ‚ö†Ô∏è
- beware: doesn't use `type` keyword even though is a type ‚ö†Ô∏è
- can use union as type for field, field can return any Object type in union
- beware: if uses a union as type for field, can query no fields without using fragment with type condition ‚ùóÔ∏è
- beware: differs from TypeScript where can access a property that is on all members of a union of object types ‚ö†Ô∏è

### Wrapping types

- list: `[ T ]` for type `T`, collection of values of given type
- non-null: `T!` for type `T`, given type without `null` value



## Input Type

- type of argument (and variable), specifies values in request
- i.e. scalar, enum, (input) object
- name of type, field must be unique, must not start with two underscores since reserved for introspection
- beware: doesn't use `type` keyword even though are all types ‚ö†Ô∏è

### Named types

#### Primitive types

- as in Output Type, see Output Type

#### Composite types

- object

```plaintext
InputObjectTypeDefinition:
    Description* "input" Name Directives* InputFieldsDefinition*

InputFieldsDefinition:
    { InputValueDefinition+ }
```

- beware: don't confuse with Object type, doesn't allow field arguments or references to abstract types ‚ùóÔ∏è

### Wrapping types

- as in Output Type, see Output Type



## Directive

```plaintext
DirectiveDefinition
    Description* "directive" @ Name ArgumentsDefinition* "on" DirectiveLocations

DirectiveLocations:
    |* DirectiveLocation
    DirectiveLocations | DirectiveLocation

DirectiveLocation:
    ExecutableDirectiveLocation
    TypeSystemDirectiveLocation

ExecutableDirectiveLocation:
    "QUERY" OR "MUTATION" OR "SUBSCRIPTION" OR "FIELD" OR "FRAGMENT_DEFINITION" OR "FRAGMENT_SPREAD" OR "INLINE_FRAGMENT" OR "VARIABLE_DEFINITION"

TypeSystemDirectiveLocation:
    "SCHEMA" OR "SCALAR" OR "OBJECT" OR "FIELD_DEFINITION" OR "ARGUMENT_DEFINITION" OR "INTERFACE" OR "UNION" OR "ENUM" OR "ENUM_VALUE" OR "INPUT_OBJECT" OR "INPUT_FIELD_DEFINITION"
```

- name of directive must be unique, not start with two underscores since reserved for introspection
- directive can't use other directive in argument that creates a cyclic reference, e.g. itself
- built-in directives in any schema engine:
    - `@deprecated(reason: String)` on field or enum: marks field or enum value as deprecated
- beware: currently spec doesn't include `@deprecated` on argument, see [#525](https://github.com/graphql/graphql-spec/pull/525)



## Description

- strings provided in documentation alongside definition
- directly in code, no need to keep documentation in sync üéâ
- can add immediately before schema, type, field in object, enum value in enum, argument, directive
- think of JSDoc comments in TypeScript
- can use markdown

```plaintext
Description
    StringValue
```



## Resources

- [GraphQL - Specification 11/2020](http://spec.graphql.org/draft/)