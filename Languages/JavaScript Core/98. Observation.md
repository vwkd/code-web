
### Third idea: Observables

- functions: dependent statements get changes "pushed", passive
- events: dependent variables "pull in" changes, proactive

- not built into any language, can use user-land libraries, most popular is Rx.io, e.g. RxJS



### Observer pattern

- software design pattern
- an object, called the subject, maintains a list of its dependents, called observers
- subject notifies observers when it changes state, usually by calling one of their methods

- allow an object to publish changes to its state
- Other objects subscribe to be immediately notified of any changes

- subject is often stream source of events, observer is stream drain
- observer subscribes to / consumes subject
- can have multiple observers per subject

- beware: we said the subject doesn't know if and which observers listen, but it holds a record of the event handlers that were registered, "technical detail" where analogy breaks down,

- use any transformation between input stream and output stream, filter, map, delay, etc.
- can chain together

- `Observable` is object that creates the subject stream

- stream of data: sequence of objects, should be immutable, asynchronously
- functions should be pure
- errors propagate through to consumer, like with promises

- subscriber gets changes until unsubscribes !!! no need to set up own event handler logic



### Observables = Events

- Observables are a more refined version of EventTarget. Their primary innovation is that the subscription itself is represented by a first-class object, the Observable, which you can then apply combinators (such as filter, map, etc.) over.

- manage concurrency with stream of events

- promises and stream of events don't work since promises only resolve once

```javascript
const click = new CustomEvent("click", {
    detail: { message: "Button clicked." }
});

const button = new EventTarget();

const p = new Promise((res, rej) => {
    button.addEventListener("click", event => {
        res(event.detail.message);
    });
});

p.then(console.log).catch(console.log);

button.dispatchEvent(click); // "Button clicked."
button.dispatchEvent(click);
// reacts just once since promise already resolved
```

- observable is event stream with promise for each event, can chain on to it, gets piped through
- can make observables from event streams using `fromEvent`


### Iterator pattern

consumer pull items one item at a time, infinite list
with error and finish callback ??

### Observer pattern

- subject / observable, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods.


producer pushes items one item at a time
modern event emitter
with error and finish callbacks

events are array items over time
Subscribing to an Event and traversing an Array are fundamentally the same operation
Array traversal is synchronous and completes, and Event traversal is asynchronous and never completes
same functions from arrays can apply to observable

map, filter, flat

collection of items over time

observable makes event first class object

 sequence of values that a data producer pushes to the consumer one after the other


### Observation

iteration: consumer pulls out multiple values from producer one at a time, consumer is in control, producer "waits" until consumer pulls new value, e.g. via iteration object, sync pull stream

observation: producer pushes multiple values to consumer one at a time, producer is in control, consumer "waits" until producer pushes new value, e.g. via event listener, sync push stream
  â†’ observation â†” iteration

async iteration: iteration, consumer pulls out promise and "waits" until resolves, pushes back value, consumer pulls next promise, async pull streams

async observation: iteration, consumer is pushed value, pushes back promise, producer "waits" until promise is resolved to push next value, producer pushes next value (i.e. handles backpressure), async push stream

What does async function * return ? should return observable ??



observer pattern: producer to push consumer one item at a time, producer is in control, it decides when

like registering for event, but with three callbacks, one for data, one for error, one for done

observable
can do same operations on observable that can do on iterable, e.g. filter, map, etc.
evaluated as data arrives, in real time
promisify event handlers, don't handle with callbacks anymore !!!!
event streams can't be chained, need to manage state variables ðŸ‘Ž





wait asynchronously on stream of values, e.g. Streams API (browser API)


- iteration: source, consumer can pull out multiple values from producer one at a time, consumer is in control, producer "waits" until consumer pulls next value, i.e. via iterator (or generator) object
- generation: sink, consumer can push in multiple values to producer one at a time, consumer is in control, producer "waits" until consumer pulls next value, i.e. via generator object

- observation: producer pushes multiple values to consumer one at a time


///


- Observable: invokable collection of future values or events, like many-valued promises ??
- Observer: collection of callbacks that knows how to listen to values delivered by the Observable
- Subscription: represents the execution of an Observable, is primarily useful for cancelling the execution.
- Subject: is the equivalent to an EventEmitter, and the only way of multicasting a value or event to multiple Observers.
- Schedulers: are centralized dispatchers to control concurrency, allowing us to coordinate when computation happens on e.g. setTimeout or requestAnimationFrame or others.
Operators: are pure functions that enable a functional programming style of dealing with collections with operations like map, filter, concat, reduce, etc.

### Observable

- object that can send multiple values to a consumer
- has a subscribe method which accepts a generator and can send it any number of values
- can be composed with higher-order combinators
- do not start emitting data until an observer has subscribed, "lazy"
- sequence of values which may be observed
- can `subscribe()` with `Observer`, returns `Subscription`

model push-based data sources such as DOM events, timer intervals, and sockets.
processing asynchronous streams of data
push-based stream protocol
managing sequences of events

push-based iterator
push items to the observer
methods `onNext()` etc. on observable,  get called instead of consumer calling them


### Observer

- receive data from an Observable
- is supplied as an argument to subscribe.
- `next()` receives next value in the sequence



///

promise-like object for an event stream

- promises: one asynchronous value

## Reactive Extensions

- manages asynchronous data streams between sources of data and components that need to react to that data

### Observable

- asynchronous sequence of data, async streams, like iterator but async, ??? push based collection
- can subscribe to listen

- operators can transform the streams


/

