# Observables

[TOC]

<!-- ToDo: Revisit if included by spec -->


## Introduction

- a better Events API
- beware: as of May 2020 not part of official spec, need to use third-party library, implementations might vary, e.g. ReactiveX with RxJS ‚ö†Ô∏è
- beware: often confused with reactive programming, not more reactive than events are reactive, see [Reactive Programming]() for actual reactive programming



## Motivation

### Data flow

- consumer: consumes value(s), current code, always point of view
- producer: produces value(s), usually external side effect, e.g. Web API
- data always flows from producer to consumer
- pull-based data flow: consumer is in control, consumer decides when to pull out a value from the producer, producer need to handle the waiting, synchronous
- push-based data flow: producer is in control, producer decides when to push out a value to the consumer, consumer need to handle the waiting, asynchronous
- beware: pull is sync and push is async from point of view of consumer, not necessarily same for producer ‚ùóÔ∏è

### Data flow types

- language implements different features to handle data flow
- differ in who has control and if data is single value or multiple values

| feature | single | multiple |
| - | - | - |
| pull | Function | Iterator |
| push | Promise | Event |

- Function produces single value, data flow is pull-based, consumer pulls it out in variable assignment
- Promise produces single value, data flow is push-based, consumer attaches handler function
- Iterator produces multiple values, data flow is pull-based, consumer pulls out in iteration
- Event produces multiple values, data flow is push-based, consumer attaches handler function

### Problems with Events

- Promises enable push-based data flow with single values
- Events enable push-based data flow with multiple values
- Events lack several important things, which Promises, also Iterator has equivalent things:
  1. producer can't notify consumer of error or completion, e.g. no error or completion callback in `.addEventListener()`
  2. producer starts pushing values immediately, doesn't wait for consumer to subscribe, e.g. can dispatch event even if nobody listens
  3. producer doesn't start again for new subscriber, pushes identical values to all subscribers at each point in time, late subscribers miss the values from the beginning



## Observable

observable is event stream, first-class object that can apply combinators over

- better Events API, fixes the above problems
- like multi-valued promise, promise that can resolve multiple times, with 1., 2. ,3.
- a real push-based complement to pull-based Iterator, with 1.
- more declarative handling of event streams with array-like operators
- replaces Event in above diagram

| feature | single | multiple |
| - | - | - |
| pull | Function | Iterator |
| push | Promise | Observable |

- two types of observables
  - cold: like multi-valued promise, i.e. like described above üëç
  - hot: like events with problem 2. and 3., i.e. just fixes 1. and adds the array-like operators üëé

- observer can't control backpressure?? like overflooding event stream
- operators can't control backpressure?? like zip with one observer faster than the other

could handle backpressure by letting consumer push back a promise to producer after event arrived, resolves promise once done handling, producer can continue pushing next value


## Implementation

<!-- ToDo: Might be outdated soon, since implementation dependent -->

- beware: will use RxJS because most popular as of May 2020, but is not standard, like any library can change at any time ‚ö†Ô∏è
- RxJS observables are cold by default üëç
- RxJS observables don't use microtask queue, are sync by default instead of async, need to manually make async üëé ‚ö†Ô∏è

```javascript
import { Observable } from "rxjs";

// sync by default
const obs = new Observable(subscriber => {
    subscriber.next(21);
    subscriber.next(42);
});

console.log("first");
obs.subscribe(x => {
    console.log(x);
});
console.log("last");

// first
// 21
// 42
// last
```

```javascript
import { Observable } from "rxjs";

// async by wrapping in Promise.resolve().then(..) or setTimeout(.., 0)
const obs = new Observable(subscriber => {
    Promise.resolve().then(() => {
        subscriber.next(21);
    });
    Promise.resolve().then(() => {
        subscriber.next(42);
    });
});

console.log("first");
obs.subscribe(x => {
    console.log(x);
});
console.log("last");

// first
// last
// 21
// 42
```

### Observing an observable

- observer / subscriber: function to observe observable ???, `next()`, `error()` and `complete()` handlers, analogous to event handler but with error and complete handler, can be three separate callbacks or object containing these methods
- observable: instance of `Observable` class, analogous to `EventTarget`
- `Observable.subscribe()`: subscribes an observer, analogous to `EventTarget.addEventListener()`, returns subscription
- subscription: instance of `Subscription` class, represents a specific execution of an observable, no analog
- `Subscription.unsubscribe()`: unsubscribes an observer, analogous to `removeEventListener()`, beware: unlike `removeEventListener()` is not on event target instance but on return value of `addEventListener()` ‚ùóÔ∏è
- beware: "subscribe(r)" and "observe(r)" are used synonymously
- if no error handler is provided an error will be thrown normally
- the complete handler is only called when the producer completes the stream, not when the consumer calls `unsubscribe()`
- many built-in methods to create observables, e.g. `of()`, `from()`, `interval()`, etc.

```javascript
// from arguments
import { of } from "rxjs";

const observable = of(1, 2, 3);

const subscription = observable.subscribe(
  next => console.log(next),
  err => console.log('Ups!', err),
  () => console.log('Done!'),
);

// 1
// 2
// 3
// Done!
```

```javascript
// from array, iterable, string, promise, etc.
import { from } from "rxjs";

const observable = from([1, 2, 3]);

const subscription = observable.subscribe(console.log);

// 1
// 2
// 3
```

```javascript
// from event stream
import { fromEvent } from "rxjs";

const btn = document.getElementById("btn");

const observable = fromEvent(btn, "click");

const subscription = observable.subscribe(console.log);

// <any events>
```

beware: most methods create sync observables, only `fromEvent()` creates an async one ‚ùóÔ∏è

```javascript
// from arguments
import { of } from "rxjs";

const observable = of(1, 2, 3);

console.log("first");
const subscription = observable.subscribe(console.log);
console.log("last");

// first
// 1
// 2
// 3
// last
```

```javascript
// from array, iterable, string, promise, etc.
import { from } from "rxjs";

const observable = from([1, 2, 3]);

console.log("first");
const subscription = observable.subscribe(console.log);
console.log("last");

// first
// 1
// 2
// 3
// last
```

```javascript
// from event stream
import { fromEvent } from "rxjs";

const btn = document.getElementById("btn");

const observable = fromEvent(btn, "click");

console.log("first");
const subscription = observable.subscribe(console.log);
console.log("last");

// first
// last
// MouseEvent {..}
// ..
```

### Creating an observable

- producer can create an observable manually ?? if not created with built-in function from array, event stream, etc.


- pass subscribe function to `Observable` constructor
passed observer argument with `next()`, `error()` and `complete()` methods, which call the equivalent handler functions

- observable contract: arbitrary many `next()` calls, first `error()` or `complete()` call ends the stream, nothing may come afterwards, i.e. emitting an error means complete won't be called ‚ùóÔ∏è

```javascript
import { Observable } from "rxjs";

const observable = new Observable(function subscribe(observer) {
    observer.next(21);
    observer.next(42);
});
```

- beware: don't forget to make the emission calls async by wrapping them in `Promise.resolve().then(..)` or `setTimeout(.., 0)` ‚ö†Ô∏è
- wrap emission calls in try/catch block and catch exception

```javascript
import { Observable } from "rxjs";

const observable = new Observable(function subscribe(observer) {
    try {
        observer.next(21);
        observer.next(42);
        observer.complete();
    } catch (e) {
        observer.error(e);
    }
});
```

unsubscription ???
unsubscribe on it, which in turn will stop the work that an Observable does and will clean up all resources that an Observable used
function returns an unsubscribe function to clear any allocated resources, can unsubscribe from subscription, e.g. stop async setInterval

define how to dispose resources of that execution
returning a custom unsubscribe function from within function subscribe()
this function is called when `Subscription.unsubscribe()` is called

```javascript
import { Observable } from "rxjs";

const observable = new Observable(function subscribe(observer) {
    const id = setInterval(() => {
        observer.next(42);
    }, 1000);

    return function unsubscribe() {
        clearInterval(id);
    };
});
```








lazy evaluation
lazy producer

beware: the difference to promises is that the observable doesn't start evaluating it's body until an observer subscribes ‚ùóÔ∏è

unlike with events there is no listener registry, does not maintain record of observers, each separate function calls of subscribe function passed in constructor

since is initialised by function, it's executed only when an observer subscribes, unlike promises ‚ùóÔ∏è

the function supplied to the Observable constructor is called when `Observable.subscribe()` is called for that observer

meaning another observer can subscribe at any time, even if it finished for a previous one

no events get emitted while nobody is subscribed, unlike events
there is no state in which emits events without an observer, starts only when observed, finishes when unsubscribed, nothing gets lost like with events
beware: different to promise, (first) event don't get buffered until observed, only starts production after observer subscribed

function is run a new for each observer / subscriber, i.e. cold observable, doesn't start until subscribed, emits individually for every subscriber
unlike events


## Transformations

array-like operations
can think of event streams as array items over time
- reactive extensions: operators on observables, e.g. transform, compose

- can compose observables, e.g. merge
- can transform observable using functions, e.g. filter, map, delay

- can chain transformations together
...`pipe()`

operators return again observable, can chain into composition
like sequence of array transformations
- can think of as promise chain through which multiple values travel one after another

- often visualised using marble diagram
- can think of as array items over time, tranformations are analogous to array functions





- can use observable to implement autocomplete in search ???
1. build observable from event stream keypress
2. map to value of input field
3. filter to take only values > 2
4. take unique until changed
3. debounce to only emit after user stopped typing
4. send of ajax request for suggestions
5. if observable didn't emit more, post response, else ignore, e.g. takeUntil
example: autocomplete
- filter duplicates
- throttle
- drop late responses

from(keypresses).map(key => input.value).filter(val => val.length > 2).takeUniqueUntilChanged().debounce().map(word => makeRequest()).takeUntil(keypress)
???


```javascript
import { of } from "rxjs";
import { map, filter } from 'rxjs/operators';

const observable = of(1, 2, 3, 4, 5);

observable.pipe(
    map(x => x * x),
    filter(x => x % 2 == 0)
    ).subscribe(console.log);

// 4
// 16
```


```javascript
import { fromEvent } from 'rxjs';

// EventTarget
const button = document.getElementById('myButton');

// Observable
const myObservable = fromEvent(button, 'click');

// Subscription
const subscription = myObservable.subscribe(event => console.log(event));
```

### Subject

- like observable, but 

equivalent to an EventEmitter
multicasting a value or event to multiple Observers.

same event stream for each observer, not separate like multi-valued promise, instead same like multiple event handlers
otherwise works like observable, can subscribe, etc.
is the better Event API, first class representation of event stream
can emit event on subject by calling `.next(v)`, `.error(e)`, `.complete()`

can convert existing observable into subject by subscribing to it with another subject and subscribe to subject, subject relays items, is like a proxy


- subject notifies registered observer of state change
- observer update their state when notified
- loosely coupled
- can add many observers, subscriber don't need to know who is observer, allows to register everyone that wants

- not responsibility of subject to change observer state
- notifies registered observers, they change their state in turn themselves, loosely coupled


### Schedulers

centralized dispatchers to control concurrency, allowing us to coordinate when computation happens on e.g. setTimeout or requestAnimationFrame or others.
Operators: are pure functions that enable a functional programming style of dealing with collections with operations like map, filter, concat, reduce, etc.


## Resources

- [ReactiveX](http://reactivex.io/), [RxJS](https://rxjs.dev/guide/overview)
- [Andr√© Staltz - The introduction to Reactive Programming you've been missing](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)
- [ReactiveX - Operators](http://reactivex.io/documentation/operators.html), [RxJs Marbles](https://rxmarbles.com/)