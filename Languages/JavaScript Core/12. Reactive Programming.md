# Reactive Programming

[TOC]



## Reactive Programming

- a declarative programming paradigm
- automatically update application on state change
- ultimate declarative programming paradigm, actually specifies _what_ the application should do instead of _how_
- goes hand in hand with functional programming, FP makes operations declarative, RP makes sequence of execution declarative
- code is run sequentially, it has no notion of time, if a value is updated nothing happens to statements that were executed before

```plaintext
// pseudocode

x = 1;
y = x * 2;
x = 21;
// y is 2 and not 42
```

- in bare computations this is fine, run code once sequentially and obtain result, no need to deal with time-varying values
- but applications keep running and handle time-varying values, side effects, changes from outside, e.g. from simple mouse clicks, mouse movement, key presses, to user inputs, network requests, etc.
- applications need to "react" to time-varying values, update application automatically when value changes
- just like spreadsheet, as soon as cell changes all dependent cells update their values automatically

```plaintext
// pseudocode, imaginary reactive language

x = <mouse-x>;
y = x * 2;
// x updates constantly as you move the mouse, y in turn as well
```

- as if specifies mathematical relationships between values, if one changes the other instantly changes, in continuous time, as if variables were entangled particles
- used to create interactive software, e.g. UI
- specify the dependencies of a variable completely at time of declaration, i.e. its dependencies are updated automatically as soon as it changes
- beware: nothing would stop you from writing circularly dependent values, however time-varying values can _not_ have circular dependencies, because in time there can't be circular dependencies without breaking causality ❗️

```plaintext
// pseudocode, imaginary reactive language

x = y;
y = x;
// if y changes, so does x, so does y, so does x...
```

- (we use dependent / independent like in math, `y = x * 2` is dependent variable, `x` is independent variable, more generally dependent statement)
- (use singular independent variable, but could be arbitrarily many, e.g. `y = a + b + c` for independent variables `a`, `b`, `c`)


- Reactive Extensions (reactive frameworks) kind of implement idea, but fall short, only use discrete event streams, miss the point of reactive programming ???
- term is misused to refer to a application that stays responsive through high loads and errors, "reactive application", see Reactive Manifesto, is a marketing term of the underlying company promoting its cloud business, has nothing to do with reactive programming



## Theory

- based on a mathematical theory, operations are provable
- need to model time-varying values, evolution of values
- use continuous time, state of application at every point in time
  can warp time by applying function, shifted, smoothed, scaled, easy in and out, etc. e.g. slow down mouse position move, shift mouse position move, 
- not discrete time, e.g. constant loop checking if values changed
- time is continuous, only gets converted to discrete time steps in last step, when outputs
  analogously how space is continuous in vector graphics, can scale up and down without loss, only gets converted to pixel in last step, when displays
- implementation is completely different ❗️
under the hood still needs event handling, prevent needless recomputation, handle event overflow

### Behavior

- value that changes over time, time-varying value, e.g. mouse position, volume slider, text value in input field, etc.
- can think of as mathematical function from time to value, _continuous_ streams of values, e.g. mouse position `f(t) = (sin(t), cos(t))`
- non-changing values are still behaviors, just a constant function, e.g. number of fingers `g(t) = 10`
- behavior represents any value, boolean, string, object, etc., analogy of mathematial function only makes sense for numbers
- first-class values

- reactive behavior: stitch together behaviors from an event whose values are behaviors, gets discontinuous function on time

- can be composed of other behaviors ???
- behaviors are "reactive values" ???
- function on behavior applies itself at every moment in time ???
- operations on behaviors become themselves behaviors ???

### Event

- event occurrence: value at a point in time
- event: stream of event occurences in time, timed occurrences, infinite list of event occurrences, e.g. mouse clicks, key presses

- inifinite list can be implemented as iterator, just returns next element

- events can be composed
- interleaved in time, sample, throw out useless values, etc.
- difficult to merge events with two even occurrences at same time

- function on event is applied on the lists, e.g. merge ???
- lazy producer, only evaluate when called ???
- act on event stream ??? could save the "update packages" or ignore them, only act on every third one, or only one the ones that are blue, etc.



## Naive implementations

- most implementations outside of Haskell don't use continuous resolution-independent time, use discrete events
- all examples here do the same

- wants dependent statements to "react" as soon as independent variable changes, re-execute automatically
- until now did manually using event handler logic

- code is always run sequentially, that's how CPUs work, can't just have dependent statements re-execute "in parallel" as soon as an independent value changes, like entangled particles, isn't possible with current computers at least
- want to hide sequential execution like in spreadsheets, make appear to be parallel
- need to re-execute the dependent statements as soon as the independent variables change
- need to figure out what needs to re-evaluate first, what depends on what, complex web of interdependencies, needs to start with the ones that don't depend on others, go upwards, "topological sorting", doesn't need to correspond to sequence how code is written
- currently programmer specifies updating mechanism manually, using functions or more commonly events
- want to abstract away the updating mechanism, as if there was no sequential time, specify only _what_ something should do, not _how_
- (note: we change `age` here manually, but imagine it could change via the outside world, e.g. mouse position, network request, etc., and the program wouldn't exit if it reached the end of the code)

```javascript
// imaginary reactive JavaScript

let age = 20;
let doubleAge = age * 2;
console.log(`Your are ${age} years old. Half-way there to ${doubleAge}.`);
// Your are 20 years old. Half-way there to 40.

age = 21;
// Your are 21 years old. Half-way there to 42.
```


### Zeroth idea: Loop

- could run a loop over all dependent statements
- if independent values changed re-execute dependent statements
- not really reactive, only reacts after the loop interval comes around, unneccessary work if nothing changed
- that is what happens in reactive frameworks each render frame



### First idea: Functions

- could use a function to updated the independent value, in it could re-run all dependent statements

```javascript
function updateAge(newAge) {
    age = newAge;
    // all statements that dependend on age
    doubleAge = age * 2;
    console.log(`Your are ${age} years old. Half-way there to ${doubleAge}.`);
}

let age = 20;
let doubleAge = age * 2;
console.log(`Your are ${age} years old. Half-way there to ${doubleAge}.`);
// Your are 20 years old. Half-way there to 40.

updateAge(21);
// Your are 21 years old. Half-way there to 42.
```

- doesn't scale
- the independent variable is responsible for re-executing dependent statements, the dependent statements need to be put in update function of _all_ independent variables they depend on, for every new dependent statement must integrate new logic into all its independent variables, i.e. here `doubleAge` and `console.log()` are within `updateAge()`, "tightly coupled"
- the dependent statements allow to be changed without noticing, side effects are not contained

### Second idea: Events

- this is what we currently use to make an application update itself on state change
- independent variable shouts out "Hey universe, I changed.", any dependent statement listens for it and re-executes itself
- independent variable doesn't need to update dependent ones anymore

```javascript
// use Events API of Browser, could have used Events API of Node as well
const ageEmitter = new EventTarget();
const update = new CustomEvent("update");

ageEmitter.addEventListener("update", () => {
    // all statements that dependend on age
    doubleAge = age * 2;
    console.log(`Your are ${age} years old. Half-way there to ${doubleAge}.`);
});

let age = 20;
let doubleAge = age * 2;
console.log(`Your are ${age} years old. Half-way there to ${doubleAge}.`);
// Your are 20 years old. Half-way there to 40.

age = 21;
ageEmitter.dispatchEvent(update);
// Your are 21 years old. Half-way there to 42.
```

- (note: since we update `age` manually we need to emit the event manually too, in reality `age` would have been updated from outside and the event would have been triggered from outside as well, imagine again the mouse position, is actually not more complex)
- can add as many event handlers listening for changes of independent variable as wants, independent value is observable, others can observe if it changes
- independent variable doesn't need to know who is dependent, just changes, dependent statements "update themselves", be "reactive"
- really dependent statements don't "update themselves", the event handler re-executes them
- still very imperative, needs to manually specify order of re-execution, maintain complex structure of events, becomes complicated with longer dependency chains
- want to hide all the event handler logic, update application on state change just like spreadsheets, without manually handling re-execution of dependent statements







## Summary

- RP and FP can be used together quite naturally
  - because the dependent variables "update themselves" we don't mutate their state anymore, actually we've hidden it in the event listener logic, they're still mutated (otherwise they couldn't possible update themselves) but contained to single point of failure, namely Observer ????, declarative FP works well with that
  - operating on streams is much easier with HOFs, again those are already used in FP

- RFP manipulates streams of data asynchronously using functions
  used more generally for any type of data streams, not only to update state of dependent variables ????@!!!



## Resources

- [Paul Stovell - What is Reactive Programming?](http://paulstovell.com/blog/reactive-programming)
- [Laurence Gonsalves - What is (functional) reactive programming?](https://stackoverflow.com/a/1028642/2607891)
- [Tikhon Jelvis - A Sensible Intro to FRP](https://begriffs.com/posts/2016-07-27-tikhon-on-frp.html)
- [Conal Elliott - The Essence and Origins of Functional Reactive Programming](https://www.youtube.com/watch?v=j3Q32brCUAI)



## TODO

- async data streams
- focus order in which _results_ need to happen, not operations !!!
- use event loop
- observable stream, subscriber, buffer

<!-- ToDo: Difference to Reactive Frameworks, Clean up Svelte.md -->

example: autocomplete
- filter duplicates
- throttle
- drop late responses