# Reactive Programming

[TOC]



## Introduction

- a declarative programming paradigm
- abstracts away time of computer, code specifies state of program for any point in time, not discrete temporal sequence of steps how its executed
- allows an application to update automatically on state change, e.g. interactive software
- often used together with functional programming, declarative operations + declarative time, functional reactive programming (FRP)
- beware: term is highly misused, e.g. by company promoting its cloud business of applications that scale dynamically (Reactive Manifesto) ‚ùóÔ∏è



## Motivation

- physical time is continuous, everything evolves continously in time, not a temporally discrete set of changes, e.g. position of a person, time itself, etc.
- a computer operates in a temporally discrete sequence of steps, ultimatively limited by clock cycle of CPU
- programming languages describe discrete steps of execution in time, imperative, designed for computer, e.g. each line of compiled code (assembly) can be thought of as one step, actually may be multiple but still discrete
- for a bare computation this is fine, just run code as sequence of steps to obtain result, can ignore time
- for complex applications not fine, need to keep running indefinitely and react to changes (side effects), need to have a notion of time to be able to react to time-varying values, e.g. show animation, process side effects like mouse clicks, mouse movement, key presses, user inputs, network requests, etc.
- implementation will always have to be discrete sequence of steps so computer can execute it one at a time, but programming language could be declarative
- ultimate declarative programming language would only describe _what_ application state for any point in time should look like, not temporally discrete steps _how_ to get to it, e.g. GUIs like spreadsheet formulas, a CSS animation rule, etc.
- can let application update its state automatically, "react" to time-varying values, just like spreadsheet, as soon as cell changes all dependent cells update their values automatically
- describe time-varying values declaratively, not discrete imperative steps in time, time of computer is abstracted away
- application time can even be continuous, needs to be discretised only when program is compiled into discrete sequence of steps for CPU, e.g. animation is continuous until output, then discretised to some number of FPS, or graphic is continuous in space, only rasterised to discrete pixels when output to screen
- a time-varying value is ultimately introduced by side effects into program, e.g. user input



## Theory

- needs first-class representation of time-varying values, not indirectly encoded in sequence of execution where history is lost
- needs continuous application time, not tied to discrete sequence of execution, resolution-independent
- only at implementation level application time is discretised upon converting program to discrete sequence of execution steps

### Behavior

- time-varying value, value that can change over time, e.g. mouse position, volume slider, text value in input field, etc.
- has access to complete time history, evolution of value
- value can be any value, e.g. boolean, string, object, etc.
- can think of as mathematical function from time to value, e.g. mouse position going in a circle with radius one around the origin of the coordinate system `f(t) = (sin(t), cos(t))`
- analogy of mathematial function breaks down if value is not a number, e.g. can't denote time-varying string, or time-varying array
- like a continuous stream of values for any point in time (like water, music, space etc., not like discrete event stream)
- non-changing values are still behaviors, just a constant function, e.g. number of continents `g(t) = 7`
- can compose with other behaviors to get new behavior, e.g. `h(t) = g(t) + f(t)`, add its value to itself from a shifted point in time `h(t) = g(t) + g(t+42)`, etc.
- can transform to get new behavior, using traditional function applied at every point in time, e.g. `toUpperCase(g(t))`, or shift time `h(t) = g(t+42)`, warp time `h(t) = g(t*2)`, etc.
- "reactive value", makes time first-class, replaces old way of thinking about values updated in discrete steps of execution, see Time for what lines of code then mean
- use behavior to define application state, e.g. `console.log(g(t))`
- can think of statements dependent on the value of a behavior as being defined _completely_ at time of declaration, updated automatically and "instantly" as soon as value of behavior changes, as if dependency were mathematical relationship, if one changes the other instantly changes, like entangled particles

### Event

- discrete stream of `(time, value)` tuples
- model discrete occurrences
- can think of as behaviors which are undefined except at discrete points in time, mathematical function with discrete set of points where its defined (domain)
- can compose with other event to get new event, interleaved in time, need to figure out what happens with two occurrences at same time
- can transform to get new event, using traditional function applied to every occurrence, e.g. filter out, manipulate, etc.
- beware: "event stream" would probably have been a more accurate term, don't confuse with normal "events" in programming languages

### Time

- distinguish "application time" from "computer time", in non-reactive language application time matches computer time
- application time is imagined to be continuous, application state is defined for all points in time
- computer time is discrete, ultimatively limited by clock cycle of CPU
- implementation needs to discretise application time, time steps need to be coarser than computer time steps, such that CPU can execute for each point in discrete application time all operations needed to determine application state
- code is written in application time
- since application time is continuous, lines of code don't correspond to discrete steps of execution in application time anymore, e.g. current line is present, lines above are past, lines below are future
- lines of code specify whole application state for any given point in application time, declarative rules instead of discrete sequence of execution, e.g. like CSS, HTML, etc.

```javascript
// pseudocode, imaginary reactive language

x = <mouse-x>;
y = x * 2;
console.log(y);
// x updates constantly as you move the mouse, any dependencies in turn as well, i.e. y and console.log(y)
```

- beware: at first it's hard to rethink what code means, doesn't correspond to sequential steps of execution in application time anymore, many example code snippets still use sequential lines to denote different points in application times ‚ö†Ô∏è

```javascript
// pseudocode, imaginary reactive language

x = 1;
y = x * 2;
x = 21; // üëé uses sequential lines of code to denote different points in application time
// y is 2 and not 42
```

- can imagine code is evaluated "instantly" for a given point in application time, or imagine application time is freezed while it is evaluated
- application is evaluated for `t = 0`, then keeps running in "loop" for continuously evolving application time until quit, at each point in application time behaviors are reevaluated and the application state recomputed, from point of view of application time updating the application state looks "instant"
- lines of code still correspond to discrete steps of execution in _computer time_, CPU can't just run operations "instantly", updating the application state takes some time, unlike entangled particles
- but can think of lines of code being run "instantly" from the point of view of application time, codes as if application time were continuous
- implementation needs to figure out how to discretise code into concrete steps of execution in computer time, how to update application state in temporally discrete sequence of steps
- beware: nothing would stop you from creating circularly dependent behaviors, however time-varying values can _not_ have circular dependencies, because in time there can't be circular dependencies without breaking causality ‚ùóÔ∏è

```javascript
// pseudocode, imaginary reactive language

x = y;
y = x;
// if y changes, so does x, so does y, so does x...
```



## Implementation

- beware: most implementations fall short of any real reactivity, as of May 2020 reactivity is not available in any mainstream programming language, only in Haskell with some libraries, e.g. Reactive-banana
- beware: "reactive" front-end frameworks only have the automatic application state update, no first-class behaviors, no events, e.g. React, Svelte
- beware: "reactive" event stream libraries just have events, no behaviors, e.g. ReactiveX
- beware: any implementations in traditional programming languages lack the syntax of making behaviors first-class values, need to work with existing non-reactive syntax, won't ever be truly reactive, needs new programming language

### Application state update

<!-- ToDo: Finish -->

- need to figure out what code to run at what times, translate code into discrete sequence of steps that computer can execute
- discretise application time into discrete points, ultimatively limited by clock cycle of CPU since needs time to execute all statements until next point in application time, usually limited much earlier by output medium, e.g. 60 Hz refresh rate of screen
- figure out what code to run at each point in discrete application time, only re-execute dependent statements for behaviors that changed their value, seems like automatic application state update, "reactive"
- implement "loop" that evaluates behaviors and updates application state for each discrete point in application time starting from `t = 0` until program stops
- figure out how to prevent needless reevaluation, but still evaluate as soon as behavior changes, not miss a state change
- figure out correct order of dependency chain, 


- figure out how to sample value and re-execute dependencies, e.g. constant loop is needless recomputation, probably event listener
- figure out how to handle output overflow, e.g. using event buffering


- need to re-execute the dependent statements as soon as the independent variables change
- need to figure out what needs to re-evaluate first, what depends on what, complex web of interdependencies, needs to start with the ones that don't depend on others, go upwards, "topological sorting", doesn't need to correspond to sequence how code is written




#### Zeroth idea: Loop

- could run a loop over all dependent statements
- if independent values changed re-execute dependent statements
- not really reactive, only reacts after the loop interval comes around, unneccessary work if nothing changed
- that is what happens in most reactive frameworks at each render frame
- needless reevaluation


#### First idea: Functions

- could use a function to updated the independent value, in it could re-run all dependent statements

```javascript
function updateAge(newAge) {
    age = newAge;
    // all statements that dependend on age
    doubleAge = age * 2;
    console.log(`Your are ${age} years old. Half-way there to ${doubleAge}.`);
}

let age = 20;
let doubleAge = age * 2;
console.log(`Your are ${age} years old. Half-way there to ${doubleAge}.`);
// Your are 20 years old. Half-way there to 40.

updateAge(21);
// Your are 21 years old. Half-way there to 42.
```

- doesn't scale
- the independent variable is responsible for re-executing dependent statements, the dependent statements need to be put in update function of _all_ independent variables they depend on, for every new dependent statement must integrate new logic into all its independent variables, i.e. here `doubleAge` and `console.log()` are within `updateAge()`, "tightly coupled"
- the dependent statements allow to be changed without noticing, side effects are not contained

#### Second idea: Events

- this is what we currently use to make an application update itself on state change
- independent variable shouts out "Hey universe, I changed.", any dependent statement listens for it and re-executes itself
- independent variable doesn't need to update dependent ones anymore

```javascript
// use Events API of Browser, could have used Events API of Node as well
const ageEmitter = new EventTarget();
const update = new CustomEvent("update");

ageEmitter.addEventListener("update", () => {
    // all statements that dependend on age
    doubleAge = age * 2;
    console.log(`Your are ${age} years old. Half-way there to ${doubleAge}.`);
});

let age = 20;
let doubleAge = age * 2;
console.log(`Your are ${age} years old. Half-way there to ${doubleAge}.`);
// Your are 20 years old. Half-way there to 40.

age = 21;
ageEmitter.dispatchEvent(update);
// Your are 21 years old. Half-way there to 42.
```

- (note: since we update `age` manually we need to emit the event manually too, in reality `age` would have been updated from outside and the event would have been triggered from outside as well, imagine again the mouse position, is actually not more complex)
- can add as many event handlers listening for changes of independent variable as wants, independent value is observable, others can observe if it changes
- independent variable doesn't need to know who is dependent, just changes, dependent statements "update themselves", be "reactive"
- really dependent statements don't "update themselves", the event handler re-executes them
- still very imperative, needs to manually specify order of re-execution, maintain complex structure of events, becomes complicated with longer dependency chains
- want to hide all the event handler logic, update application on state change just like spreadsheets, without manually handling re-execution of dependent statements






- (note: we change `age` here manually, but imagine it could change via the outside world, e.g. mouse position, network request, etc., and the program wouldn't exit if it reached the end of the code)

```javascript
// imaginary reactive JavaScript

let age = 20;
let doubleAge = age * 2;
console.log(`Your are ${age} years old. Half-way there to ${doubleAge}.`);
// Your are 20 years old. Half-way there to 40.

age = 21;
// Your are 21 years old. Half-way there to 42.
```




## Resources

- [Paul Stovell - What is Reactive Programming?](http://paulstovell.com/blog/reactive-programming)
- [Laurence Gonsalves - What is (functional) reactive programming?](https://stackoverflow.com/a/1028642/2607891)
- [Tikhon Jelvis - A Sensible Intro to FRP](https://begriffs.com/posts/2016-07-27-tikhon-on-frp.html)
- [Conal Elliott - The Essence and Origins of Functional Reactive Programming](https://www.youtube.com/watch?v=j3Q32brCUAI)
- [Conal Elliott - What is (functional) reactive programming?](https://stackoverflow.com/a/1030631/2607891)