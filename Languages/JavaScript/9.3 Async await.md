## Async await



<!-- todo: add https://developers.google.com/web/fundamentals/primers/async-functions -->
<!-- todo: move async function from 8. Iterators and Generators to here -->
<!-- todo: add https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of -->

## Introduction

- sugar syntax for promises (with ES2017)
- has same scope, can access variables from different callbacks easily 🎉
- has try... catch again, original error handling 🎉
- looks like code stops, jumps out?? to next outer?? await and continues there
- beware: doesn't actually stop ❗️
- beware: async code path remains separate from sync code path, can't merge code paths again, async is only run after sync is done ⚠










<!-- todo: finish -->

## Top-level await

- async await in top-level possible
- only possible in module
- module is treated as if were handler of async function
- beware: top-level await blocks execution of rest of module !!!

> Modules maintain the same ordering as in ES2015 for when they start executing. If a module reaches an await, it will yield control and let other modules initialize themselves in the same well-specified order.

> modules always initially start running in the same post-order traversal established in ES2015: execution of module bodies starts with the deepest imports, in the order that the import statements for them are reached. After a top-level await is reached, control is passed to start the next module in this traversal order, or to other asynchronously scheduled code.

> When a module includes a top-level await (even if that await is not dynamically reached), this is not synchronous, and at the very least takes one trip through the Promise job queue. However, module subgraphs which do not use top-level await continue to run synchronously in exactly the same way as without this proposal.