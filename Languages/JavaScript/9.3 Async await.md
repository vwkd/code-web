## Async await



<!-- todo: add https://developers.google.com/web/fundamentals/primers/async-functions -->
<!-- todo: move async function from 8. Iterators and Generators to here -->
<!-- todo: add https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of -->

## Introduction

- sugar syntax for promises (with ES2017)
- has same scope, can access variables from different callbacks easily ðŸŽ‰
- has try... catch again, original error handling ðŸŽ‰
- looks like code stops, jumps out?? to next outer?? await and continues there
- beware: doesn't actually stop â—ï¸
- beware: async code path remains separate from sync code path, can't merge code paths again, async is only run after sync is done âš 




## Async iteration

- async code with promises is still not as nice as consecutive lines of sync code
- needs to juggle everything through promise chain, e.g. can't access values from earlier handlers without explicitly handing them through whole chain

```javascript
function asyncFn1(val1) {
    return new Promise((res, rej) => {
        setTimeout(() => {
            res(val1 * 2);
        }, 1000);
    });
}

function asyncFn2(val2) {
    return new Promise((res, rej) => {
        setTimeout(() => {
            res(val2 * 2);
        }, 1000);
    });
}

asyncFn1(10.5).then(asyncFn2).then(console.log).catch(console.log); // 42 
```

- combine generators and promises, generator function that yields promises
- consumer needs to pull promise from generator, resolve outside, push resolved value back inside, subsequent computations can use that value
- becomes nested promise chain, use helper function to recursively resolve promises, push resolved value back in iterator, and finally return promise with last value

```javascript
function spawn(iterator) {
    return new Promise((res, rej) => {
        (function onResult(previousValue) {
            const { value, done } = iterator.next(previousValue);
            if (!done) {
                value.then(onResult, rej);
            } else {
                res(value);
            }
        })();
    });
}

function* asyncFn(val1) {
    const val2 = yield asyncFn1(val1);
    const val3 = yield asyncFn2(val2);
    return val3;
}

spawn(asyncFn(10.5)).then(console.log).catch(console.log); // 42
```



## Async functions

- just sugar over async iteration, abstract away the helper function (with ES2017) ðŸš€
- use `async` before function name instead of `*`, `await` in function body instead of `yield`
- async code that looks like sync code, consecutive lines, no promise chains or callbacks, can use try...catch again ðŸš€
- non-blocking code is as easy as sync code ðŸš€

```javascript
async function asyncFn(val1) {
    const val2 = await asyncFn1(val1);
    const val3 = await asyncFn2(val2);
    return val3;
}

asyncFn(42).then(console.log).catch(console.log); // 42
```

- allows for sync code in between without needing to wrap in promise handler to make async and return implicit promise ðŸŽ‰

```javascript
async function func() {
  const x = Promise.resolve(42);

  /* sync code here */

  return x;
}

func().then(console.log).catch(console.log); // 42
```

```javascript
const x = Promise.resolve(42);

x.then(data => { /* sync code here */ return data; }).then(console.log).catch(console.log); // 42    
```

- allows later handler to access the result from any earlier handler without the result needing to be carried through the entire promise chain, i.e. unwrap promise value and rewrap again at end in resolved promise even if didn't need value at all ðŸŽ‰

```javascript
async function func() {
    const x = Promise.resolve(4);

    const y = (await x) / 2;

    return (await x) * y;
}

func().then(console.log).catch(console.log); // 8
```

```javascript
const x = Promise.resolve(4);

x.then(x => { return { x: x, y: x / 2 }; }).then(({ x, y }) => x * y).then(console.log); // 8
```

- looks like async function pauses until awaited promise has settled, i.e. can use result variable within sync code like normal sync code â—ï¸
- if expression is not a promise, it is converted to a resolved promise, i.e. `Promise.resolve(expr)`, then evaluated as value again
- beware: can not use `await` in nested functions or callbacks, similar to `yield`, but can use inside argument position â—ï¸
- async function returns implicit promise, resolves with `value` if function returns or rejects with `error` if function throws uncaught error
- `await` can only be used inside `async` function, evaluates as the value of the fulfilled promise or throws result of rejected promise, i.e. any unhandled rejected promises trickle up until most outer async function, must have a catch at least for the most outer async function so doesn't exit with `Unhandled promise rejection` â—ï¸
- beware: sync code after async function is run first before any awaited promise is resolved, since handlers are scheduled on microtask queue and async function just hides handlers that resolve awaited promises as seen in async iteration â—ï¸

```javascript
console.log("Start.");

(async function func() {
    const str = await Promise.resolve("Hello World!")
    console.log(str);
})().catch(console.log);

console.log("End.");

// Start.
// End.
// Hello World!
```

- inside the async function awaited promises block like sync code, if wants them to start concurrently or in parallel needs to await them later â—ï¸

```javascript
function oneSecond() {
    return new Promise((res, rej) => {
        setTimeout(() => {
            res("Resolved fast.");
        }, 1000);
    });
}

function twoSeconds() {
    return new Promise((res, rej) => {
        setTimeout(() => {
            res("Resolved slow.");
        }, 2000);
    });
}
```

```javascript
async function sequential() {
    console.log("Starting promises sequentially...");

    const slow = await twoSeconds();
    console.log(slow);

    const fast = await oneSecond();
    console.log(fast);
}

sequential().catch(console.log);
// Starting promises sequentially... [0s since start]
// Resolved slow.                    [2s since start]
// Resolved fast.                    [3s since start]
```

```javascript
async function concurrent() {
    console.log("Starting promises concurrently...");

    const slow = twoSeconds();
    const fast = oneSecond();

    console.log(await slow);
    console.log(await fast);
}

concurrent().catch(console.log);
// Starting promises concurrently... [0s since start]
// Resolved slow.                    [2s since start]
// Resolved fast.                    [2s since start]
```

```javascript
function parallel() {
    console.log("Starting promises in parallel...");

    const slow = twoSeconds();
    const fast = oneSecond();

    slow.then(console.log).catch(console.log);
    fast.then(console.log).catch(console.log);
}

parallel();
// Starting promises in parallel... [0s since start]
// Resolved fast.                   [1s since start]
// Resolved slow.                   [2s since start]

// or as async function with error handling outside
async function parallel() {
    console.log("Starting promises in parallel...");

    const slow = twoSeconds();
    const fast = oneSecond();

    await Promise.all([
        (async() => {console.log(await slow);})(),
        (async() => {console.log(await fast);})()
    ]);
}

parallel().catch(console.log);
```

- in an async function `return`ing a promise and `return await`ing a promise is the same if the promise resolves, but if it rejects a `return` always returns the rejected promise, while an awaited promise throws and can be catched inside, if it is not catched it returns the rejected promise similarly to a `return`

```javascript
function failedPromise() {
    return new Promise((res, rej) => {
        setTimeout(() => {
            rej("Failed.");
        }, 1000);
    });
}
```

```javascript
async function func() {
    try {
        return failedPromise();
    } catch (err) {
        console.log("Handled error inside.");
    }
}

func().catch(err => { console.log("Handled error outside."); });
// Handled error outside.
```

```javascript
async function func() {
    try {
        return await failedPromise();
    } catch (err) {
        console.log("Handled error inside.");
    }
}

func().catch(err => { console.log("Handled error outside."); });
// Handled error inside.
```

- beware: can not stop async function in between `await`s, unlike generator function with custom helper function















<!-- todo: finish -->

## Top-level await

- async await in top-level possible
- only possible in module
- module is treated as if were handler of async function
- beware: top-level await blocks execution of rest of module !!!

> Modules maintain the same ordering as in ES2015 for when they start executing. If a module reaches an await, it will yield control and let other modules initialize themselves in the same well-specified order.

> modules always initially start running in the same post-order traversal established in ES2015: execution of module bodies starts with the deepest imports, in the order that the import statements for them are reached. After a top-level await is reached, control is passed to start the next module in this traversal order, or to other asynchronously scheduled code.

> When a module includes a top-level await (even if that await is not dynamically reached), this is not synchronous, and at the very least takes one trip through the Promise job queue. However, module subgraphs which do not use top-level await continue to run synchronously in exactly the same way as without this proposal.