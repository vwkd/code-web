## Async await



## Introduction

- sugar syntax for combination of promises and generators (with ES2017)
- solves problems of Promises üéâ



## generator yielding promises

- combine pausing of generators with promises

"""generators yielding Promises that then control the generator's *iterator* to advance it to completion"""

- generator pauses to yield promise
- iterator control pulls promise out, waits for it to resolve, pushes result back in (as value or error)

iterating a generator that yields promises
outside calls .next() on the iterator, receives the promise at the yield call, and waits for it to resolve before calling .next() with the result (or .throw() if it rejects).

When you await a promise, the function is paused in a non-blocking way until the promise settles.
await on a promise. This halts the function in a non-blocking way, waits for the promise to resolve & returns the value. If the promise rejects, it throws with the rejection value, so you can deal with it using catch.

- generator body looks like sync code even though is async, async code that looks like sync code

looks like generator pauses until promise settled
can use result like in sync code
in generator looks like yield waits for fulfilled promise to continue or throws if rejected

can use `try...catch` again
    gets try... catch back again, original error handling üéâ
`yield` hides the promise chain, looks like one big code block
promise chain is hidden between `yield` blocks, consecutive lines, handler is like after a `yield` statement
thanks to shared variables in generator can access state from earlier handler in later
    has same scope, can access variables from different callbacks easily üéâ

also wrap `yield`ed value into a promise, incase it's not a promise, i.e. using `Promise.resolve(..)`
Anything you await is passed through `Promise.resolve()`, so you can safely await non-native promises.

can think of `yield` continuing if promise fulfill or throw if promise rejects
in outside gets promise of (last) value
resolves with return value of function or rejects with `error` if function throws uncaught error

```javascript
function* gen() {
    console.log("start");
    const val = yield somePromise(); // or yield* if it's another generator
    console.log("end");
    return val;
}

const it = gen();

const {value, _} = it.next();

Promise.resolve(value).then(val => {
    it.next(val);
}, err => {
    it.throw(err);
})
 .then(.., ..)
```


`return` and `return yield` are same if promise resolves, but different if it rejects, since can catch it with later inside, while with former settles to rejected promise outside

- in an async function `return`ing a promise and `return await`ing a promise is the same if the promise resolves, but if it rejects a `return` always returns the rejected promise, while an awaited promise throws and can be catched inside, if it is not catched it returns the rejected promise similarly to a `return`


- generator function that yields promises
- consumer needs to pull promise from generator, resolve outside, push resolved value back inside, subsequent computations can use that value
- becomes nested promise chain, use helper function to recursively resolve promises, push resolved value back in iterator, and finally return promise with last value



## Driver

manually iterating the iterator, pulling promises resolving and pushing back in is cumbersome
needs to adapt if there are multiple promises

- above only works for a generator which yields a single promise
- repeat iteration control until all promises are resolved
- put iteration control into own function
- returns itself a promise for the completion of the generator with the last resolved value
- can think of as a driver, repeatedly continues generator until receives last promise
- beware: can not pause driver in between `yield`s unlike when driven manually ‚ùóÔ∏è
looks like generator pauses, but driver drives it continuously, can't stop ‚ùóÔ∏è


```javascript
function spawn(gen, ...args) {
  const it = gen(...args);
  return new Promise((res, rej) => {

    (function pushBackIn(val, err) {
      try {
        // in first recursion is `it.next()` since both `val` and `err` are `undefined`
        const { value, done } = err ? it.throw(err) : it.next(val);

        if (done) {
          res(value);
        } else {
          Promise.resolve(value).then(val => pushBackIn(val, undefined), err => pushBackIn(undefined, err));
        }
      } catch (err) {
        rej(err);
      }
    })();

  });
}

spawn(gen).then(.., ..)
```



## Async await

- sugar that abstracts away driver of generator

async func: is generator which yields promises, called normally, behind the scenes passed to a spawn function, passed to a driver

- calls async function instead of generator, uses `async function` instead of `function*` and `await` instead of `yield`(`*`)
- calls async function directly instead of driver with generator
- beware: can use async function as arrow function, unlike generator yet as of 2021 ‚ùóÔ∏è

```javascript
function* gen() {
    console.log("start");
    const val = yield somePromise(); // or yield* if it's another generator
    console.log("end");
    return val;
}

spawn(gen).then(.., ..);

async function new() {
    console.log("start");
    const val = await somePromise();
    console.log("end");
    return val;
}

new().then(.., ..);
```



## Top-level await

- await in top-level of module
- module is treated as if it were within an async function
- beware: takes at least one trip through the microtask queue before it's run ‚ùóÔ∏è



## Resources

- [Jake Archibald - await vs return vs return await](https://jakearchibald.com/2017/await-vs-return-vs-return-await/)