

for 2 async ops
return promises
asyncOp1(arg)
asyncOp1(arg)

3 cases
- async ops depend on each other
run AO sequentially (including the handling)

```javascript
const val1 = await asyncOp1(arg)
// handle one here
const val2 = await asyncOp1(val1)
// handle two here
// or handle both here
```

4 possibilities, total time (without handle) for whole thing
both succeed: t1 + t2
op1 fails: op2 is never run, t1
op1 succeeds, op2 fails: t1 + t2
both fail: like "op1 fails"

|op1|op2|time|
|--|--|--|
|success|success|t1+t2|
|failure|success/failure (never run)|t1|
|success|failure|t1+t2|

- handling of ops depend on each other
  i.e. fails if either fails, i.e. succeeds if both succeed
  fail <=> !A or !B which means succeed <=> !(fail) <=> !(!A or !B) <=> A and B
run AO concurrently
handle sequentially

Promise.all()

4 possibilities, total time (without handle) for whole thing
both succeed: t of longer
op1 fails, op2 succeeds: t1
op1 succeeds, op2 fails: t2
both fail: t of shorter

|op1|op2|time|
|--|--|--|
|success|success|t of longer|
|failure|success|t1|
|success|failure|t2|
|failure|failure|t of shorter|

- neither depend on each other
  i.e. fails if both fail, succeeds if either succeeds
  fail <=> !A and !B which means succeed <=> !(fail) <=> !(!A and !B) <=> A or B
run AO and handle concurrently

Promise.any()

4 possibilities
both succeed: t of longer
op1 fails, op2 succeeds: t2
op1 succeeds, op2 fails: t1
both fail: t of longer

|op1|op2|time|
|--|--|--|
|success|success|t of longer|
|failure|success|t2|
|success|failure|t1|
|failure|failure|t of longer|



## Scheduling

 if wants them to start concurrently or in parallel needs to await them later ❗️

```javascript
function promise1() {
    return new Promise((res, rej) => {
        setTimeout(() => {
            res("val1");
        }, 2000);
    });
}

function promise2() {
    return new Promise((res, rej) => {
        setTimeout(() => {
            res("val2");
        }, 1000);
    });
}
```

### sequential

note: promise 2 never starts if promise 1 fails

```javascript

console.log("start");

try {
    const val1 = await promise1();
    console.log(val1);
} catch (err1) {
    console.log(err1)
}

try {
    const val2 = await promise2();
    console.log(val2);
} catch (err2) {
    console.log(err2)
}
// start          [0s since start]
// val1           [2s since start]
// val2           [3s since start]
```

### concurrent

wants to handle both ??


```javascript
console.log("start");

// beware: uses "dangerous" property of attaching handlers later ⚠️
const p1 = promise1();
const p2 = promise2();

// idea 1
// beware: don't use, because if p2 settles before p1 then it has no handler ⚠️
try {
    const val1 = await p1;
    console.log(val1);
} catch (err1) {
    console.log(err1)
}
// +[2 sec] (first)
try {
    const val1 = await p2;
    console.log(val2);
} catch (err2) {
    console.log(err2)
}
// +[1 sec] (second)

// idea 2
// beware: Promise.all() fails fast, if any fails, then the others are ignored no matter what they do
try {
    const val1and2 = await Promise.all([p1, p2]);
    // +[2 sec] (longest)
    console.log(val1);
    console.log(val2);
} catch (err1or2) {
    // +[1 sec] (shortest)
    console.log(err1or2)
}

// idea 3
// beware: Promise.allSettled() always fulfills
// needs to handle separately depending on state
const valorerr1and2 = await Promise.allSettled([p1, p2]);
// +[2 sec] (longest)
console.log(valorerr1and2);

// 2 secs if both succeed
// 1 sec if last fails, 2 sec if first fails
// beware: if one fails the other isn't handled, even if fails as well !!!
// beware: Promise.all() fails fast, if any fails, then the others are ignored no matter what they do
return Promise.all([p1, p2]);

// 2 secs always
return Promise.allSettled([p1, p2]);

// if wants to handle success in any case, error outside
return Promise.allSettled([
    p1.then(console.log),
    p2.then(console.log)
]);




// start          [0s since start]
// val1           [2s since start]
// val2           [2s since start]
```

```javascript
async function parallel() {
    console.log("start");

    const p1 = promise1();
    const p2 = promise2();

    // await Promise.allSettled([
    //     (async() => {
    //         console.log(await p1);
    //         })(),
    //     (async() => {
    //         console.log(await p2);
    //         })()
    // ]);

    await Promise.allSettled([
        p1.then(console.log),
        p2.then(console.log)
    ]);
}

parallel();
// start          [0s since start]
// val2           [1s since start]
// val1           [2s since start]



    await Promise.all([
        (async() => {console.log(await slow);})(),
        (async() => {console.log(await fast);})()
    ]);
}

parallel().catch(console.log);
```



beware: don't `await` call to promise source, if wants them to be parallel
`await` only when they're used, but beware of missing handler for second promise if settles before first !!!


start of independent async ops, then await them later when needs them, such that they can run parallel, e.g. using .map() instead of for loop with await
