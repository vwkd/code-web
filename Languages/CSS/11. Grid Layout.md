# Grid Layout

[TOC]


<!-- ToDo: finish -->
<!-- todo: remove unnecessary "grid" fillerword, e.g. explicit ~grid~ track -->
<!-- todo: add example code for almost everything -->

## Introduction

- a regular layout, for applications
- two-dimensional layout since uses grid, for one-dimensional layout see Flex Layout
- replaces Table Layout üéâ



## Terminology

- grid line: horizontal or vertical line
- grid: set of intersecting grid lines
- grid track: space between two adjacent grid lines, defines columns and rows
- grid cell: intersection of a row and a column
- grid area: rectangular set of adjacent grid cells



## Tracks

- rows / columns are relative to logical inline / block directions, see Writing Mode
- beware: can't specify directions independent of writing mode like in Flex Layout, not needed since can specify exact placement of items, see Placement ‚ùóÔ∏è
- explicit or implicit

### Track size

- breath of a track
- can be fixed, flexible, or content-based ??? not context based by percentage ??

#### `<length-percentage>`

- non-negative
- percentage relative to corresponding dimension of the content area of the grid container

#### `min-content`

- largest min-content contribution of a grid item in the track

#### `max-content`

- largest max-content contribution of a grid item in the track

#### `minmax(minimum, maximum)`

- flexible value that grows within the range
- `auto` value
  - as minimum: largest minimum size of a grid item in the track ??? i.e. often but not always `min-content` ???
  <!-- todo: see 6.6 -->
  - as maximum: `max-content`, but track size can be bigger due to `*-content` alignment properties, see Alignment ‚ùóÔ∏è
beware: can set `<flex>` factor only as maximum and not as minimum ‚ùóÔ∏è

#### `auto`

- computes to `minmax(auto, auto)`, i.e. usually `minmax(min-content, max-content)`

#### fit-content(limit)

- `min(minmax(auto, max-content), minmax(auto, limit))`

- limit is `<length-percentage>`
  where minimum represents an auto minimum (which is often, but not always, equal to a min-content minimum)
  limit is the track sizing function passed as an argument to fit-content()
  i.e. the smaller of minmax(auto, max-content) and minmax(auto, limit)
?? like max-content, but with upper bound the argument, lower bound the minimum size 

#### `<flex>`

- non-negative

beware: outside of `minmax()` has a lower bound of `auto`, i.e. like `minmax(auto, <flex>)`
??? fr is bound below by minimum content size

- beware: positive free space is only distributed after all non-flexible track sizing functions have reached their maximum
and after gutters have been computed


### Track list

- space-separated list of track sizes
- beware: here leave out line names for clarity, see Named lines

```css
/* breadth values */
<flexible-breadth>       = <length-percentage> | <flex> | min-content | max-content | auto
<inflexible-breadth>     = <length-percentage> | min-content | max-content | auto
<fixed-breadth>          = <length-percentage>

/* track sizes */
<flexible-size>          = <flexible-breadth> | minmax( <inflexible-breadth> , <flexible-breadth> ) | fit-content( <length-percentage> )
<fixed-size>             = <fixed-breadth> | minmax( <fixed-breadth> , <flexible-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )

/* repeat functions */
<flexible-repeat>        = repeat( <integer [1,‚àû]> , <flexible-size>+ )
<auto-repeat>            = repeat( auto-fill | auto-fit , <fixed-size>+ )
<fixed-repeat>           = repeat( <integer [1,‚àû]> , <fixed-size>+ )

/* track lists */
<flexible-list>          = [ <flexible-size> | <flexible-repeat> ]+
<auto-flexible-list>     = [ <fixed-size> | <fixed-repeat> ]* <auto-repeat> [ <fixed-size> | <fixed-repeat> ]*
```

#### `repeat()`

- track list fragment from repeating a track list fragment, i.e. creates a pattern
- auto repetition to create as many tracks as needed to fill the available space
- `auto-fit` is like `auto-fill`, except after Placement any empty tracks are removed
- beware: can't nest `repeat()` functions ‚ùóÔ∏è
- beware: auto repetition requires fixed track sizes, can't be used with flexible track sizes ‚ùóÔ∏è
- beware: a track list can only contain a single auto repetition ‚ùóÔ∏è
- beware: returns at least the non-repeated track list fragment, even if tracks already overflow ‚ùóÔ∏è
- can combine auto repetition with `minmax()` and `<flex>` factor to let tracks grow to fill any remaining space

```html
<div class="container">
  <div class="item">1</div>
  <div class="item">2</div>
  <div class="item">3</div>
</div>
```

```css
/* change viewport width to see effect */
/* needs at least 800px+3rem to see effect of auto-fit vs auto-fill */

.container {
  display: grid;
  /* create as many 200px columns as possible, grow if space left over */
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  /* like auto-fill, but don't create empty tracks if all items are placed */
  /* grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); */
  grid-gap: 1rem;
}

.item {
  border: 1px solid black;
  background-color: lightgrey;
  padding: 0.5rem 0;
  text-align: center;
  font-family: sans-serif;
}
```

### Explicit tracks

- always created
- as many as have size and/or name specified
- beware: final grid may end up larger due to implicit tracks, see Implicit tracks ‚ùóÔ∏è

#### `grid-template-columns`, `grid-template-rows`

- specify track size of explicit grid tracks in column, row
- not inherited
- applies only to grid containers
- values: `none`, `<track-list>`, `<auto-track-list>`, see Track Size
- initial value: `none`
- beware: with `none` explicit tracks can still be created by `grid-template-area` ‚ùóÔ∏è

#### `grid-template`

- shorthand for `grid-template-columns` and `grid-template-rows`, i.e. specifies all explicit track sizes
- first `grid-template-rows`, then `grid-template-columns` separated by a `/`
- beware: resets omitted explicit tracks properties to their initial value ‚ùóÔ∏è

### Implicit tracks

- created if grid items are placed outside of explicit tracks, see Placement
- as many as needed
- beware: can't guarantee size of final grid, depends on number of implicit tracks generated ‚ùóÔ∏è

#### `grid-auto-columns`, `grid-auto-rows`

- specify track size of implicit grid tracks in column, row
- beware: also sizes additional explicit grid tracks from `grid-template-areas` that aren't sized by `grid-template-columns` / `grid-template-rows` ‚ùóÔ∏è
- not inherited
- applies only to grid containers
- relative to logical inline / block directions instead of physical directions, see Writing Mode
- values: `<track-size>`+, see Track Size
- initial value: `auto`, i.e. ??? SAME SIZE ?? MIN-CONTENT ??

tracks repeat if not enough specified
beware: can't specify individual track size for every implicit track since can grow to be be arbitrarily many ‚ùóÔ∏è
If multiple track sizes are given, the pattern is repeated as necessary to find the size of the affected tracks.

The first track after the last explicitly-sized track receives the first specified size, and so on forwards;
???and the last implicit grid track before the explicit grid receives the last specified size, and so on backwards. ??? WHAT BEFORE EXPLICIT GRID ???

### `grid`

<!-- todo: 7.8 -->
- shorthand for ???, i.e. specifies all explicit and implicit track sizes
- first ??, then ?? separated by a `/`
??? first row then column 
also `grid-auto-flow` in between
- beware: also sets `grid-auto-flow` ‚ùóÔ∏è
- beware: resets omitted properties to their initial value ‚ùóÔ∏è

Note that you can only specify the explicit or the implicit grid properties in a single grid declaration

beware: use grid over grid-template because it resets `grid-auto-columns`, `grid-auto-rows` as well ?!?!

### Named grid lines

can name lines by adding name in brackets in track list between track sizes
`<custom-ident>`, except can not be the keywords `span` and `auto`

```css
  grid-template-columns: [one] 150px [two] 1fr [three];

```
can place independent of line index, can redefine named line in media query, e.g. portrait and landscape mode


?? WORKS FOR IMPLICIT TRACKS ??

beware: in `repeat()` function line names at start and end are concatenated in the pattern, e.g. `repeat(2, [a] 1fr [b])` computes to `[a] 1fr [b a] 1fr [b]` ‚ùóÔ∏è

### Named grid areas

?? WORKS FOR IMPLICIT TRACKS ??

<!-- todo: 7.3 -->
- `grid-template-areas`
- specifies names for explicit grid tracks
??? creates named grid area
- beware: if specifies names for more explicit tracks than sized by `grid-template-columns` / `grid-template-rows`, creates new explicit tracks that are sized by `grid-auto-columns`, `grid-auto-rows` ‚ùóÔ∏è
- beware: total number of explicit tracks is larger length of value list of `grid-template-columns`, `grid-template-rows` and `grid-template-areas` ‚ùóÔ∏è
- not inherited
- applies only to grid containers
- values: `none`, `<string>`+
- initial value: `none`

The rows, columns and areas of the grid are defined visually
     * using the grid-template-areas property.  Each string is a row,
     * and each UNIQUE word an area.  The number of words in a string
     * determines the number of columns. Note the number of words
     * in each string must be identical.
tracks using ascii art
one string for each row
one word for each column
multiple space is ignored, e.g. can align ascii art
if repeats name, spans accross tracks
can use any unicode characters, e.g. "." as throwaway name that's not used ???
??? what happens if non-rectangular ascii art, i.e. rows don't have same number of columns ???

holy grail layout example
```
"header header header"
"nav    main   aside"
"footer footer footer";
```

??? can also create named grid area by two named grid lines with "[*-start]" "[*-end]" for same name
??? actually just creates named grid lines on all four sides of the area of the form "[*-start]" and "[*-end]" that are then used in placement ?!?!
  i.e. doesn't actually name a grid area, names just grid lines

beware: only useful if places item using name in `grid-area`

in shorthand can create named grid areas
  add names for each row of `grid-template-area` before the corresponding row track size
  if no track size after names, then auto is assumed

```css
myel {
  grid-template-columns: 100px 200px 300px;
  grid-template-rows: auto 400px;
  grid-template-areas: "header header header"
                        "nav   main   aside";
}

myel {
  grid-template: "header header header"
                 "nav    main   aside" 400px
                 / 100px 200px 300px;
}
```

Note: Named grid areas automatically generate implicitly-assigned line names "\*-start" and "\*-end", so specifying grid-row-start: foo will choose the start edge of that named grid area (unless another line named foo-start was explicitly specified before it).

here the `<custom-ident>` can not be the keywords `span` and `auto` ??!!


can use to make placement independent of actual tracks, can redefine tracks in media query, e.g. portrait and landscape orientation
??? makes grid area of placement independent of actual track numbers, can redefine grid area in media queries
need to use named grid area for placement, e.g. in grid-area property



## Placement

grid item is placed in a grid area
references the grid lines around grid area (shorthands make seem as if referenced area directly)
can reference grid lines by numeric index or by name
beware: grid area can't be referenced directly, instead references grid lines around it, just shorthands make it seem as if references directly !!!

ASSIGNED TO GRID AREA, DOESN'T CREATE IT
can specify grid area manually or automatically, or mix of both

- beware: affects only visual rendering, keyboard navigation and screen reader still use document tree order ‚ùóÔ∏è

??? WHAT IF GRID ITEM IS BIGGER THAN ITS GRID AREA, e.g. if grid is fixed track size and item is bigger ?? OVERFLOWS ??

beware: can place items outside of explicit grid INTO IMPLICIT GRID if index too large, too many items to auto place, etc.
  especially auto-placement
i.e. line index is out of range, or too many items in auto-placement algorithm

### Manual placement

specifies grid area into which grid item is placed
ASSIGNED TO GRID AREA, DOESN'T CREATE IT

grid items can overlap if placed in intersecting grid areas or uses negative margins
beware: order of stacking is same as visual order, not order of document tree, see Stacking
!!! beware: `order` modifies stacking and auto placement, i.e. only identical to z-index in manual placement

---

grid area is defined by start and end grid line
  instead of start or end position can also define span over how many tracks
  beware: if start and end are specified, span has no effect ??? NO, END HAS NO EFFECT ???
Grid area can be named explicitly or referenced implicitly by its bounding grid lines

`<grid-line> = auto | <integer> | [ span && <integer> ]`

beware: ignores named grid areas here for simplicity

grid line can be referred to by numerical index, or by an author-specified name
Numeric indexes in the grid-placement properties count from the edges of the explicit grid
Positive indexes count from the start side (starting from 1 for the start-most explicit line)
negative indexes count from the end side (starting from -1 for the end-most explicit line)
beware: index of grid lines are reversed if writing mode changes !!
Note: Note that grid indexes are writing mode relative. For example, in a right-to-left language like Arabic, the first column is the rightmost column.
the explicit grid contains at least one grid line in each axis

if both `grid-*-start` and `grid-*-end` are numerical indexes, and start line is further end-ward than the end line, swap the two lines
  e.g. `grid-row-start: 4; grid-row-end: 2;`
if both `grid-*-start` and `grid-*-end` are numerical indexes and start line is equal to the end line, then end line is ignored, i.e. `grid-*-end` computes to `auto`
  i.e. effectively `span 1`
  e.g. `grid-row-start: 8; grid-row-end: 8;`

forwards (positive) and backwards (negative) numerical grid coordinates, named grid lines, and named grid areas

"span" is offset of opposite grid line
??? Negative integers or zero are invalid
if both `grid-*-start` and `grid-*-end` are spans, then end line is ignored, i.e. `grid-*-end` computes to `auto`
  e.g. `grid-row-start: span 2; grid-row-end: span 2;`


#### grid-row-start, grid-row-end, grid-column-start, grid-column-end

specifying the inline-start, block-start, inline-end, and block-end edges of the item's grid area
- values: `<grid-line>`
- initial value: `auto`
- applies only to grid items
- not inherited

`auto` means uses auto placement ?!?! figure rest out

#### `grid-row`, `grid-column`

- shorthand for `grid-row-*`, `grid-column-*`
- first `grid-*-start`, then optional `grid-*-end` separated by a `/`
- beware: resets omitted properties to their initial value ‚ùóÔ∏è

#### `grid-area`

- shorthand for `grid-row` and `grid-column`
- first `grid-row-start`, then optional `grid-column-start` separated by a `/`, then optional `grid-row-end` separated by a `/`, then optional `grid-column-end` separated by a `/`
- beware: resets omitted properties to their initial value ‚ùóÔ∏è

#### Named grid line

for all above can specify named grid line
can place independent of numeric index of grid line, if named grid line is redefined in media query

If there are multiple lines of the same name, they can be indexed
by default treats as if provided index 1
order of integer and custom-ident doesn't matter
integer can be negative, counts in reverse, starting from the end edge of the explicit grid.
zero integer is invalid

???if both `grid-*-start` and `grid-*-end` are named grid lines / areas and start line is equal to the end line, then ??????end line is ignored, i.e. `grid-*-end` computes to `auto`
      e.g. `grid-row-start: text; grid-row-end: text;`
      --> important, since `grid-row` / `grid-column` shorthand set both ends to same <custom-ident>

<!-- todo: improve in-code comments -->
```css
myel {
  /* Span between the 5th and 7th lines named "text". */
  grid-row: text 5 / text 7;
}
```

can also span across lines with a name
order of "span" and [integer + custom-ident] doesn't matter
but Negative integers or zero are invalid for "span"

<!-- todo: improve in-code comments -->
```css
myel {
  /* start at the 5th line, then span across to next "text" line */
  grid-row: 5 / span text 1;
}

myel {
  /* start at the 5th line named "text", then span across two "text" lines (i.e. to the 7th line named "text") */
  grid-row: text 5 / span text 2;
}
```

beware: an auto-placed item can‚Äôt span to a named line ?!?!
if one of `grid-*-start` and `grid-*-end` is `auto` and other is a span to a named line, then span is ignored, i.e. span computes to `auto`
  e.g. `/* grid-row-start: auto; */ grid-row-end: span text;`

```
myel {
  /* invalid ?!?! */
  grid-row: auto / span text;
}
```

---

beware: If not enough lines with that name exist, all implicit grid lines are assumed to have that name for the purpose of finding this position !!!!

<!-- todo: clean up code, add picture from SPEC -->
```css
/* two grid lines numbered 1 and 2, "foo" is first line in implicit grid since not in explicit grid */
.grid { grid-template-columns: 100px; }
.griditem { grid-column: span foo / 4; }
```

??? WHY IS THE BELOW USEFUL ??? because named grid areas create such lines ??
??? SO, E.G. GRID-*-START SEARCHES FOR TWO LINES, NAME <custom-ident> AND <custom-ident>-START ??? WHICH ONE FIRST ??? the one with the lower numeric index ???
for grid-*-start can specify <custom-ident> for named line with the name <custom-ident>-start
for grid-*-end can specify <custom-ident> for named line with the name <custom-ident>-end

for `grid-row`, `grid-column` shorthands: if the first value is a <custom-ident>, the second value is also set to that <custom-ident>
  i.e. ??? useful only if its a named grid area ??? if grid line makes no sense since same line ???

for `grid-area` shorthand: if start side is a <custom-ident> and end side is omitted, the end side is also set to that <custom-ident>
  if only one <custom-ident> is specified, then all sides are set to that <custom-ident>
  i.e. ??? useful only if its a named grid area ??? if grid line makes no sense since same line ???

#### Named grid area

for `grid-row-*`, `grid-column-*` can specify named grid area, then partially aligns to that edge
???for `grid-row`, `grid-column` as well ??? ALIGNS TWO EDGES ???
for `grid-area` can specify named grid area, then places in that grid area
can place independent of numeric indexes of grid area, if named grid area is redefined in media query

Note that if a named grid area and a named line have the same name, the placement algorithm will prefer to use named grid area‚Äôs lines instead. ?? SO, LINE OR AREA ??


### Auto placement

placement of grid items without a manual placement
places remaining grid items without manual placement

automatically places into an unoccupied grid area
places into first empty grid areas
by default, along row from row-start direction towards row-end direction, then wrap around to next row from column-start direction towards column-end direction, see `grid-auto-flow`
beware: may grow grid and create implicit tracks if needed
  may generate implicit tracks if explicit tracks are full
  adds new rows / columns as necessary
by default automatically placed in visual order WITHIN AUTO PLACED GRID ITEMS, NOT MANUALLY PLACED ONES, see `grid-auto-flow`

beware: auto placed items never overlap any other grid item, because laid out only after manual placement

beware: auto placement doesn't maintain any order relative to manually placed items, fills empty space, just maintains order within auto placed items, e.g. auto placed item can come before before manually placed item even though is later in source

can place certain items, leave rest for auto placement in between

can partially place items, remaining information is figured out by auto placement, like constraints, e.g. only span, or only start / end position
if only start / end position, span is set to 1
beware: by default, an item is placed into one cell

<!-- todo: improve in-code comment -->
```css
myel {
  /* auto placement makes span 1 */
  grid-row-start: 2;
  /* grid-row-end: 3; */
  grid-column-start: 3;
  /* grid-column-end: 4; */
}
```

<!-- todo: improve in-code comment -->
```css
myel {
  /* auto placement finds first grid-row-end and grid-column-end that satisfy span constraint */
  grid-row-start: span 2;
  grid-column-start: span 3;
}
```

#### `grid-auto-flow`

- specifies direction in which boxes are laid out in auto placement
- also specifies packing
- beware: should have been two separate properties, conflates direction with packing ‚ùóÔ∏è

- not inherited
- applies only to grid containers
- values: `[ row | column ] || dense`
- initial value: `row`

- beware: doesn't affect stacking order since doesn't change order of boxes but only the direction, see Order ‚ùóÔ∏è

beware: without any explicit tracks, by default lays out items in block direction, differs from Flex Layout which lays out inline direction ‚ùóÔ∏è

##### Packing

items of different sizes may create holes, could fill by later items, backfills
  skips empty space to place a larger item, could return to fill those spaces with later items
sparse packing keeps order of auto-placed items, leaves holes
dense packing ignores order of auto-placed items, fills holes
- by default, packing is sparse, 
- if specifies `dense`, packing is dense
- beware: if packing is `dense`, the order of items may not be as specified by `order` ‚ùóÔ∏è

#### Order

- specifies order in which boxes are laid out in auto placement
- `order`
- not inherited
- applies only to grid items
- values: `<integer>`
- initial value: `0`
- element with lower number comes first in row/column-start direction (depending on `grid-auto-flow`)
- elements with same number are laid out by order in document tree, earlier one is towards row/column-start direction (depending on `grid-auto-flow`)
- beware: can use negative numbers to always show first since default is zero ‚ùóÔ∏è
- beware: elements with positive order number come after non-ordered elements since default is zero ‚ùóÔ∏è
- beware: order of stacking is same as Order, not order of document tree, see Stacking



## Size

let's grid determine size from placement, different than Flow Layout where specifies size on item
beware: use auto sizing of items to adapt to track size, different to Flex Layout where size on item determined layout

BUT INITIAL POSITION OF ABSOLUTE POSITIONED GRID ITEM IS RELATIVE TO CONTAINER !?!?!?!?!

- beware: minimum size `auto` value of grid item that is not a scroll container, spans at least one track in that axis whose min track sizing function is auto, and spans more than one track in that axis of which none are flexible, then it resolves to `min-content` (with some adjustments) instead of zero ‚ö†Ô∏è

### `auto` size

depends on self-alignment values



## Gutters

empty grid tracks between other grid tracks
spaces grid tracks from each other
only in between tracks, not before first / behind last

by default grid tracks are packed tightly
can use gap properties to make appear as separate 

can only specify for all rows / columns, not for individual ones
need to use margins of grid item instead

???!!!row-gap, column-gap can add additional space between tracks, i.e. grid is not purely the sum of the track sizes

- beware: size of final grid depends also on gutters ‚ùóÔ∏è

### `grid-row-gap`, `grid-column-gap`

- specify gutters in row, column

### `grid-gap`

- shorthand for `grid-row-gap` and `grid-column-gap`



## Alignment

<!-- todo: 10. -->

like for Flex Layout but in two!!! dimensions
?? has no effect if no positive free space
?? aligns in negative free space as well ??

"justify" is inline direction
"align" for block direction
??? also in Flex Layout
beware: in Grid Layout are same for different direction, in Flex Layout has multiple items for justify but ony single item (in line) for align
*-items properties are shortcuts for *-self properties of all child elements

*-content aligns the tracks in a container ??? 
???!!!justify-content, align-content can add additional space between tracks, i.e. grid is not purely the sum of the track sizes
??? what if grid container is smaller, tracks overflow, aligns in negative free space ??? TRACK CAN'T OVERFLOW 
aligns grid tracks in container
??? safe keyword

*-self aligns the item in its grid area ???
?!?! self-alignment properties (justify-self and align-self) determine actual position within of grid item in containing block, i.e. grid area
by default stretches over its whole grid area
??? what if grid area is smaller, item overflows, aligns in negative free space ???

?!?! beware: by default columns are full width because of `justify-content: stretch`
?? WHY NOT ROWS ??
BEWARE: TRACK SIZE IS LARGER THAN SPECIFIED IF JUSTIFY-CONTENT / ALIGN-CONTENT (?) : STRETCH IS SPECIFIED !!!!
Note: auto track sizes (and only auto track sizes) can be stretched by the align-content and justify-content properties.
i.e. can grow `auto` track sizes !!!
track size can be bigger due to `*-content` alignment properties, see Alignment ‚ùóÔ∏è

WHAT DO MARGINS DO? COPY DROM FLEX LAYOUT


## Absolute positioning
<!-- move to Positioned Layout -->

if containing block of absolutely positioned element is a grid container, can apply grid placement properties to element as if it were a grid item
`auto` value computes to (relevant edge of) padding box of grid container, no auto placement
i.e. by default, abspos element has same position as if container were not grid container
doesn't contribute to implicit grid, track sizing, etc.
non existent lines or out-of-bounds line compute to `auto`

offset properties are relative to grid area, i.e. as if grid area were containing block

<!-- todo: what happens if grid container is (also) parent of abspos element? -->



## Flex Layout comparison

two dimensional
alignment of content in both dimensions
explicitly position items in the grid, i.e. can create "holes"
allows explicit overlapping of items

Although many layouts can be expressed with either Grid or Flexbox, they each have their specialties. Grid enforces

2-dimensional alignment
top-down approach to layout, i.e. size tracks, not item itself
explicit overlapping of items, i.e. by placing in overlapping grid areas

columns / rows can use flexible sizing

sizes grid tracks and lets item size automatically grow to fill, instead of specifying item size ??
specifies size and location in grid (parent), instead of on child itself, doesn't need to hope they line up, guaranteed

can't change direction of grid, uses writing mode, not needed since grid itself provides any directions
??? also when laying out automatically 

SAME:

order property
margins, auto margins

floats don't apply
no margin collapse

## TODO

6.2. Grid Item Sizing
6.6. Automatic Minimum Size of Grid Items

11.

SUBGRID FOR LEVEL 2



## Resources

- [W3C - CSS Grid Layout Module Level 1](https://www.w3.org/TR/css-grid-1/)